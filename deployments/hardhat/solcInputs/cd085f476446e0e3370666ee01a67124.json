{
  "language": "Solidity",
  "sources": {
    "contracts/Acropolis.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./utils/ContractGuard.sol\";\r\nimport \"./interfaces/IBasisAsset.sol\";\r\nimport \"./interfaces/ITreasury.sol\";\r\nimport \"./owner/Operator.sol\";\r\n\r\ncontract ShareWrapper {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public share;\r\n\r\n    uint256 private _totalSupply;\r\n    mapping(address => uint256) private _balances;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function stake(uint256 amount) public virtual {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n        share.safeTransferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public virtual {\r\n        uint256 andrasShare = _balances[msg.sender];\r\n        require(andrasShare >= amount, \"Acropolis: withdraw request greater than staked amount\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[msg.sender] = andrasShare.sub(amount);\r\n        share.safeTransfer(msg.sender, amount);\r\n    }\r\n}\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract Acropolis is ShareWrapper, ContractGuard, Operator {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    /* ========== DATA STRUCTURES ========== */\r\n\r\n    struct Ecclesiaseat {\r\n        uint256 lastSnapshotIndex;\r\n        uint256 rewardEarned;\r\n        uint256 epochTimerStart;\r\n    }\r\n\r\n    struct AcropolisSnapshot {\r\n        uint256 time;\r\n        uint256 rewardReceived;\r\n        uint256 rewardPerShare;\r\n    }\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    // flags\r\n    bool public initialized = false;\r\n\r\n    IERC20 public based;\r\n    ITreasury public treasury;\r\n\r\n    mapping(address => Ecclesiaseat) public demos;\r\n    AcropolisSnapshot[] public acropolisHistory;\r\n\r\n    uint256 public withdrawLockupEpochs;\r\n    uint256 public rewardLockupEpochs;\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event Initialized(address indexed executor, uint256 at);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    event RewardAdded(address indexed user, uint256 reward);\r\n\r\n    /* ========== Modifiers =============== */\r\n\r\n    modifier andrasExists {\r\n        require(balanceOf(msg.sender) > 0, \"Acropolis: The andras does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier updateReward(address andras) {\r\n        if (andras != address(0)) {\r\n            Ecclesiaseat memory seat = demos[andras];\r\n            seat.rewardEarned = earned(andras);\r\n            seat.lastSnapshotIndex = latestSnapshotIndex();\r\n            demos[andras] = seat;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier notInitialized {\r\n        require(!initialized, \"Acropolis: already initialized\");\r\n        _;\r\n    }\r\n\r\n    /* ========== GOVERNANCE ========== */\r\n\r\n    function initialize(\r\n        IERC20 _based,\r\n        IERC20 _share,\r\n        ITreasury _treasury\r\n    ) public notInitialized onlyOperator {\r\n        based = _based;\r\n        share = _share;\r\n        treasury = _treasury;\r\n\r\n        AcropolisSnapshot memory genesisSnapshot = AcropolisSnapshot({time : block.number, rewardReceived : 0, rewardPerShare : 0});\r\n        acropolisHistory.push(genesisSnapshot);\r\n\r\n        withdrawLockupEpochs = 4; // Lock for 4 epochs (24h) before release withdraw\r\n        rewardLockupEpochs = 2; // Lock for 2 epochs (12h) before release claimReward\r\n\r\n        initialized = true;\r\n        emit Initialized(msg.sender, block.number);\r\n    }\r\n\r\n    function setOperator(address _operator) external onlyOperator {\r\n        transferOperator(_operator);\r\n    }\r\n\r\n    function renounceOperator() external onlyOperator {\r\n        _renounceOperator();\r\n    }\r\n\r\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external onlyOperator {\r\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, \"_withdrawLockupEpochs: out of range\"); // <= 2 week\r\n        require(_withdrawLockupEpochs > 0 && _rewardLockupEpochs > 0);\r\n        withdrawLockupEpochs = _withdrawLockupEpochs;\r\n        rewardLockupEpochs = _rewardLockupEpochs;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    // =========== Snapshot getters =========== //\r\n\r\n    function latestSnapshotIndex() public view returns (uint256) {\r\n        return acropolisHistory.length.sub(1);\r\n    }\r\n\r\n    function getLatestSnapshot() internal view returns (AcropolisSnapshot memory) {\r\n        return acropolisHistory[latestSnapshotIndex()];\r\n    }\r\n\r\n    function getLastSnapshotIndexOf(address andras) public view returns (uint256) {\r\n        return demos[andras].lastSnapshotIndex;\r\n    }\r\n\r\n    function getLastSnapshotOf(address andras) internal view returns (AcropolisSnapshot memory) {\r\n        return acropolisHistory[getLastSnapshotIndexOf(andras)];\r\n    }\r\n\r\n    function canWithdraw(address andras) external view returns (bool) {\r\n        return demos[andras].epochTimerStart.add(withdrawLockupEpochs) <= treasury.epoch();\r\n    }\r\n\r\n    function canClaimReward(address andras) external view returns (bool) {\r\n        return demos[andras].epochTimerStart.add(rewardLockupEpochs) <= treasury.epoch();\r\n    }\r\n\r\n    function epoch() external view returns (uint256) {\r\n        return treasury.epoch();\r\n    }\r\n\r\n    function nextEpochPoint() external view returns (uint256) {\r\n        return treasury.nextEpochPoint();\r\n    }\r\n\r\n    function getBasedPrice() external view returns (uint256) {\r\n        return treasury.getBasedPrice();\r\n    }\r\n\r\n    // =========== Andras getters =========== //\r\n\r\n    function rewardPerShare() public view returns (uint256) {\r\n        return getLatestSnapshot().rewardPerShare;\r\n    }\r\n\r\n    function earned(address andras) public view returns (uint256) {\r\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\r\n        uint256 storedRPS = getLastSnapshotOf(andras).rewardPerShare;\r\n\r\n        return balanceOf(andras).mul(latestRPS.sub(storedRPS)).div(1e18).add(demos[andras].rewardEarned);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function stake(uint256 amount) public override onlyOneBlock updateReward(msg.sender) {\r\n        require(amount > 0, \"Acropolis: Cannot stake 0\");\r\n        super.stake(amount);\r\n        demos[msg.sender].epochTimerStart = treasury.epoch(); // reset timer\r\n        emit Staked(msg.sender, amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public override onlyOneBlock andrasExists updateReward(msg.sender) {\r\n        require(amount > 0, \"Acropolis: Cannot withdraw 0\");\r\n        require(demos[msg.sender].epochTimerStart.add(withdrawLockupEpochs) <= treasury.epoch(), \"Acropolis: still in withdraw lockup\");\r\n        claimReward();\r\n        super.withdraw(amount);\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(balanceOf(msg.sender));\r\n    }\r\n\r\n    function claimReward() public updateReward(msg.sender) {\r\n        uint256 reward = demos[msg.sender].rewardEarned;\r\n        if (reward > 0) {\r\n            require(demos[msg.sender].epochTimerStart.add(rewardLockupEpochs) <= treasury.epoch(), \"Acropolis: still in reward lockup\");\r\n            demos[msg.sender].epochTimerStart = treasury.epoch(); // reset timer\r\n            demos[msg.sender].rewardEarned = 0;\r\n            based.safeTransfer(msg.sender, reward);\r\n            emit RewardPaid(msg.sender, reward);\r\n        }\r\n    }\r\n\r\n    function allocateSeigniorage(uint256 amount) external onlyOneBlock onlyOperator {\r\n        require(amount > 0, \"Acropolis: Cannot allocate 0\");\r\n        require(totalSupply() > 0, \"Acropolis: Cannot allocate when totalSupply is 0\");\r\n\r\n        // Create & add new snapshot\r\n        uint256 prevRPS = getLatestSnapshot().rewardPerShare;\r\n        uint256 nextRPS = prevRPS.add(amount.mul(1e18).div(totalSupply()));\r\n\r\n        AcropolisSnapshot memory newSnapshot = AcropolisSnapshot({\r\n            time: block.number,\r\n            rewardReceived: amount,\r\n            rewardPerShare: nextRPS\r\n        });\r\n        acropolisHistory.push(newSnapshot);\r\n\r\n        based.safeTransferFrom(msg.sender, address(this), amount);\r\n        emit RewardAdded(msg.sender, amount);\r\n    }\r\n\r\n    function governanceRecoverUnsupported(IERC20 _token, uint256 _amount, address _to) external onlyOperator {\r\n        // do not allow to drain core tokens\r\n        require(address(_token) != address(based), \"based\");\r\n        require(address(_token) != address(share), \"share\");\r\n        _token.safeTransfer(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/utils/ContractGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract ContractGuard {\r\n    mapping(uint256 => mapping(address => bool)) private _status;\r\n\r\n    function checkSameOriginReentranted() internal view returns (bool) {\r\n        return _status[block.number][tx.origin];\r\n    }\r\n\r\n    function checkSameSenderReentranted() internal view returns (bool) {\r\n        return _status[block.number][msg.sender];\r\n    }\r\n\r\n    modifier onlyOneBlock() {\r\n        require(!checkSameOriginReentranted(), \"ContractGuard: one block, one function\");\r\n        require(!checkSameSenderReentranted(), \"ContractGuard: one block, one function\");\r\n\r\n        _;\r\n\r\n        _status[block.number][tx.origin] = true;\r\n        _status[block.number][msg.sender] = true;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IBasisAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBasisAsset {\r\n    function mint(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function burn(uint256 amount) external;\r\n\r\n    function burnFrom(address from, uint256 amount) external;\r\n\r\n    function isOperator() external returns (bool);\r\n\r\n    function operator() external view returns (address);\r\n\r\n    function transferOperator(address newOperator_) external;\r\n}\r\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITreasury {\r\n    function epoch() external view returns (uint256);\r\n\r\n    function nextEpochPoint() external view returns (uint256);\r\n\r\n    function getBasedPrice() external view returns (uint256);\r\n\r\n    function buyBonds(uint256 amount, uint256 targetPrice) external;\r\n\r\n    function redeemBonds(uint256 amount, uint256 targetPrice) external;\r\n}\r\n"
    },
    "contracts/owner/Operator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Operator is Context, Ownable {\r\n    address private _operator;\r\n\r\n    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\r\n\r\n    constructor() {\r\n        _operator = _msgSender();\r\n        emit OperatorTransferred(address(0), _operator);\r\n    }\r\n\r\n    function operator() public view returns (address) {\r\n        return _operator;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(_operator == msg.sender, \"operator: caller is not the operator\");\r\n        _;\r\n    }\r\n\r\n    function isOperator() public view returns (bool) {\r\n        return _msgSender() == _operator;\r\n    }\r\n\r\n    function transferOperator(address newOperator_) public onlyOwner {\r\n        _transferOperator(newOperator_);\r\n    }\r\n\r\n    function _transferOperator(address newOperator_) internal {\r\n        require(newOperator_ != address(0), \"operator: zero address given for new operator\");\r\n        emit OperatorTransferred(address(0), newOperator_);\r\n        _operator = newOperator_;\r\n    }\r\n\r\n    function _renounceOperator() public onlyOwner {\r\n        emit OperatorTransferred(_operator, address(0));\r\n        _operator = address(0);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"./lib/Babylonian.sol\";\r\nimport \"./owner/Operator.sol\";\r\nimport \"./utils/ContractGuard.sol\";\r\nimport \"./interfaces/IBasisAsset.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./interfaces/IAcropolis.sol\";\r\nimport \"./owner/Operator.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract Treasury is ContractGuard, Operator {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    /* ========= CONSTANT VARIABLES ======== */\r\n\r\n    uint256 public constant PERIOD = 6 hours;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    // flags\r\n    bool public initialized = false;\r\n\r\n    // epoch\r\n    uint256 public startTime;\r\n    uint256 public epoch = 0;\r\n    uint256 public epochSupplyContractionLeft = 0;\r\n\r\n    //=================================================================// exclusions from total supply\r\n    address[] public excludedFromTotalSupply = [\r\n        address(0x9Ec66B9409d4cD8D4a4C90950Ff0fd26bB39ad84) // BasedGenesisPool\r\n    ];\r\n\r\n    // core components\r\n    address public based;\r\n    address public bbond;\r\n    address public bshare;\r\n\r\n    address public acropolis;\r\n    address public basedOracle;\r\n\r\n    // price\r\n    uint256 public basedPriceOne;\r\n    uint256 public basedPriceCeiling;\r\n\r\n    uint256 public seigniorageSaved;\r\n\r\n    uint256[] public supplyTiers;\r\n    uint256[] public maxExpansionTiers;\r\n\r\n    uint256 public maxSupplyExpansionPercent;\r\n    uint256 public bondDepletionFloorPercent;\r\n    uint256 public seigniorageExpansionFloorPercent;\r\n    uint256 public maxSupplyContractionPercent;\r\n    uint256 public maxDebtRatioPercent;\r\n\r\n    // 14 first epochs (0.5 week) with 4.5% expansion regardless of BASED price\r\n    uint256 public bootstrapEpochs;\r\n    uint256 public bootstrapSupplyExpansionPercent;\r\n\r\n    /* =================== Added variables =================== */\r\n    uint256 public previousEpochBasedPrice;\r\n    uint256 public maxDiscountRate; // when purchasing bond\r\n    uint256 public maxPremiumRate;  // when redeeming bond\r\n    uint256 public discountPercent;\r\n    uint256 public premiumThreshold;\r\n    uint256 public premiumPercent;\r\n    uint256 public mintingFactorForPayingDebt; // print extra BASED during debt phase\r\n\r\n    address public daoFund;\r\n    uint256 public daoFundSharedPercent;\r\n\r\n    //=================================================//\r\n\r\n    address public devFund;\r\n    uint256 public devFundSharedPercent;\r\n    address public teamFund;\r\n    uint256 public teamFundSharedPercent;\r\n\r\n    /* =================== Events =================== */\r\n\r\n    event Initialized(address indexed executor, uint256 at);\r\n    event BurnedBonds(address indexed from, uint256 bondAmount);\r\n    event RedeemedBonds(address indexed from, uint256 basedAmount, uint256 bondAmount);\r\n    event BoughtBonds(address indexed from, uint256 basedAmount, uint256 bondAmount);\r\n    event TreasuryFunded(uint256 timestamp, uint256 seigniorage);\r\n    event AcropolisFunded(uint256 timestamp, uint256 seigniorage);\r\n    event DaoFundFunded(uint256 timestamp, uint256 seigniorage);\r\n    event DevFundFunded(uint256 timestamp, uint256 seigniorage);\r\n    event TeamFundFunded(uint256 timestamp, uint256 seigniorage);\r\n\r\n    /* =================== Modifier =================== */\r\n\r\n    modifier checkCondition {\r\n        require(block.timestamp >= startTime, \"Treasury: not started yet\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier checkEpoch {\r\n        require(block.timestamp >= nextEpochPoint(), \"Treasury: not opened yet\");\r\n\r\n        _;\r\n\r\n        epoch = epoch.add(1);\r\n        epochSupplyContractionLeft = (getBasedPrice() > basedPriceCeiling) ? 0 : getBasedCirculatingSupply().mul(maxSupplyContractionPercent).div(10000);\r\n    }\r\n\r\n    modifier checkOperator {\r\n        require(\r\n                IBasisAsset(based).operator() == address(this) &&\r\n                IBasisAsset(bbond).operator() == address(this) &&\r\n                IBasisAsset(bshare).operator() == address(this) &&\r\n                Operator(acropolis).operator() == address(this),\r\n            \"Treasury: need more permission\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    modifier notInitialized {\r\n        require(!initialized, \"Treasury: already initialized\");\r\n\r\n        _;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    function isInitialized() public view returns (bool) {\r\n        return initialized;\r\n    }\r\n\r\n    // epoch\r\n    function nextEpochPoint() public view returns (uint256) {\r\n        return startTime.add(epoch.mul(PERIOD));\r\n    }\r\n\r\n    // oracle\r\n    function getBasedPrice() public view returns (uint256 basedPrice) {\r\n        try IOracle(basedOracle).consult(based, 1e18) returns (uint144 price) {\r\n            return uint256(price);\r\n        } catch {\r\n            revert(\"Treasury: failed to consult BASED price from the oracle\");\r\n        }\r\n    }\r\n\r\n    function getBasedUpdatedPrice() public view returns (uint256 _basedPrice) {\r\n        try IOracle(basedOracle).twap(based, 1e18) returns (uint144 price) {\r\n            return uint256(price);\r\n        } catch {\r\n            revert(\"Treasury: failed to consult BASED price from the oracle\");\r\n        }\r\n    }\r\n\r\n    // budget\r\n    function getReserve() public view returns (uint256) {\r\n        return seigniorageSaved;\r\n    }\r\n\r\n    function getBurnableBasedLeft() public view returns (uint256 _burnableBasedLeft) {\r\n        uint256 _basedPrice = getBasedPrice();\r\n        if (_basedPrice <= basedPriceOne) {\r\n            uint256 _basedSupply = getBasedCirculatingSupply();\r\n            uint256 _bondMaxSupply = _basedSupply.mul(maxDebtRatioPercent).div(10000);\r\n            uint256 _bondSupply = IERC20(bbond).totalSupply();\r\n            if (_bondMaxSupply > _bondSupply) {\r\n                uint256 _maxMintableBond = _bondMaxSupply.sub(_bondSupply);\r\n                uint256 _maxBurnableBased = _maxMintableBond.mul(_basedPrice).div(1e18);\r\n                _burnableBasedLeft = Math.min(epochSupplyContractionLeft, _maxBurnableBased);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getRedeemableBonds() public view returns (uint256 _redeemableBonds) {\r\n        uint256 _basedPrice = getBasedPrice();\r\n        if (_basedPrice > basedPriceCeiling) {\r\n            uint256 _totalBased = IERC20(based).balanceOf(address(this));\r\n            uint256 _rate = getBondPremiumRate();\r\n            if (_rate > 0) {\r\n                _redeemableBonds = _totalBased.mul(1e18).div(_rate);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBondDiscountRate() public view returns (uint256 _rate) {\r\n        uint256 _basedPrice = getBasedPrice();\r\n        if (_basedPrice <= basedPriceOne) {\r\n            if (discountPercent == 0) {\r\n                // no discount\r\n                _rate = basedPriceOne;\r\n            } else {\r\n                uint256 _bondAmount = basedPriceOne.mul(1e18).div(_basedPrice); // to burn 1 BASED\r\n                uint256 _discountAmount = _bondAmount.sub(basedPriceOne).mul(discountPercent).div(10000);\r\n                _rate = basedPriceOne.add(_discountAmount);\r\n                if (maxDiscountRate > 0 && _rate > maxDiscountRate) {\r\n                    _rate = maxDiscountRate;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBondPremiumRate() public view returns (uint256 _rate) {\r\n        uint256 _basedPrice = getBasedPrice();\r\n        if (_basedPrice > basedPriceCeiling) {\r\n            uint256 _basedPricePremiumThreshold = basedPriceOne.mul(premiumThreshold).div(100);\r\n            if (_basedPrice >= _basedPricePremiumThreshold) {\r\n                //Price > 1.10\r\n                uint256 _premiumAmount = _basedPrice.sub(basedPriceOne).mul(premiumPercent).div(10000);\r\n                _rate = basedPriceOne.add(_premiumAmount);\r\n                if (maxPremiumRate > 0 && _rate > maxPremiumRate) {\r\n                    _rate = maxPremiumRate;\r\n                }\r\n            } else {\r\n                // no premium bonus\r\n                _rate = basedPriceOne;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ========== GOVERNANCE ========== */\r\n\r\n    function initialize(\r\n        address _based,\r\n        address _bbond,\r\n        address _bshare,\r\n        address _basedOracle,\r\n        address _acropolis,\r\n        uint256 _startTime\r\n    ) public notInitialized onlyOperator {\r\n        based = _based;\r\n        bbond = _bbond;\r\n        bshare = _bshare;\r\n        basedOracle = _basedOracle;\r\n        acropolis = _acropolis;\r\n        startTime = _startTime;\r\n\r\n        basedPriceOne = 10 ** 18;\r\n        basedPriceCeiling = basedPriceOne.mul(101).div(100);\r\n\r\n        // Dynamic max expansion percent\r\n        supplyTiers = [0 ether, 206000 ether, 386000 ether, 530000 ether, 1300000 ether, 5000000 ether, 10000000 ether];\r\n        maxExpansionTiers = [600, 500, 450, 400, 200, 100, 50];\r\n\r\n        maxSupplyExpansionPercent = 600; // Upto 6% supply for expansion\r\n\r\n        bondDepletionFloorPercent = 10000; // 100% of Bond supply for depletion floor\r\n        seigniorageExpansionFloorPercent = 3500; // At least 35% of expansion reserved for acropolis\r\n        maxSupplyContractionPercent = 300; // Upto 3.0% supply for contraction (to burn BASED and mint bBOND)\r\n        maxDebtRatioPercent = 3500; // Upto 35% supply of bBOND to purchase\r\n\r\n        premiumThreshold = 110;\r\n        premiumPercent = 7000;\r\n\r\n        // First 14 epochs with 6% expansion\r\n        bootstrapEpochs = 14;\r\n        bootstrapSupplyExpansionPercent = 600;\r\n\r\n        // set seigniorageSaved to it's balance\r\n        seigniorageSaved = IERC20(based).balanceOf(address(this));\r\n\r\n        initialized = true;\r\n        emit Initialized(msg.sender, block.number);\r\n    }\r\n\r\n    function setOperator(address _operator) external onlyOperator {\r\n        transferOperator(_operator);\r\n    }\r\n\r\n    function renounceOperator() external onlyOperator {\r\n        _renounceOperator();\r\n    }\r\n\r\n    function setAcropolis(address _acropolis) external onlyOperator {\r\n        acropolis = _acropolis;\r\n    }\r\n\r\n    function setBasedOracle(address _basedOracle) external onlyOperator {\r\n        basedOracle = _basedOracle;\r\n    }\r\n\r\n    function setBasedPriceCeiling(uint256 _basedPriceCeiling) external onlyOperator {\r\n        require(_basedPriceCeiling >= basedPriceOne && _basedPriceCeiling <= basedPriceOne.mul(120).div(100), \"out of range\"); // [$1.0, $1.2]\r\n        basedPriceCeiling = _basedPriceCeiling;\r\n    }\r\n\r\n    function setMaxSupplyExpansionPercents(uint256 _maxSupplyExpansionPercent) external onlyOperator {\r\n        require(_maxSupplyExpansionPercent >= 10 && _maxSupplyExpansionPercent <= 1000, \"_maxSupplyExpansionPercent: out of range\"); // [0.1%, 10%]\r\n        maxSupplyExpansionPercent = _maxSupplyExpansionPercent;\r\n    }\r\n    // =================== ALTER THE NUMBERS IN LOGIC!!!! =================== //\r\n    function setSupplyTiersEntry(uint8 _index, uint256 _value) external onlyOperator returns (bool) {\r\n        require(_index >= 0, \"Index has to be higher than 0\");\r\n        require(_index < 7, \"Index has to be lower than count of tiers\");\r\n        if (_index > 0) {\r\n            require(_value > supplyTiers[_index - 1]);\r\n        }\r\n        if (_index < 6) {\r\n            require(_value < supplyTiers[_index + 1]);\r\n        }\r\n        supplyTiers[_index] = _value;\r\n        return true;\r\n    }\r\n\r\n    function setMaxExpansionTiersEntry(uint8 _index, uint256 _value) external onlyOperator returns (bool) {\r\n        require(_index >= 0, \"Index has to be higher than 0\");\r\n        require(_index < 7, \"Index has to be lower than count of tiers\");\r\n        require(_value >= 10 && _value <= 1000, \"_value: out of range\"); // [0.1%, 10%]\r\n        maxExpansionTiers[_index] = _value;\r\n        return true;\r\n    }\r\n\r\n    function setBondDepletionFloorPercent(uint256 _bondDepletionFloorPercent) external onlyOperator {\r\n        require(_bondDepletionFloorPercent >= 500 && _bondDepletionFloorPercent <= 10000, \"out of range\"); // [5%, 100%]\r\n        bondDepletionFloorPercent = _bondDepletionFloorPercent;\r\n    }\r\n\r\n    function setMaxSupplyContractionPercent(uint256 _maxSupplyContractionPercent) external onlyOperator {\r\n        require(_maxSupplyContractionPercent >= 100 && _maxSupplyContractionPercent <= 1500, \"out of range\"); // [0.1%, 15%]\r\n        maxSupplyContractionPercent = _maxSupplyContractionPercent;\r\n    }\r\n\r\n    function setMaxDebtRatioPercent(uint256 _maxDebtRatioPercent) external onlyOperator {\r\n        require(_maxDebtRatioPercent >= 1000 && _maxDebtRatioPercent <= 10000, \"out of range\"); // [10%, 100%]\r\n        maxDebtRatioPercent = _maxDebtRatioPercent;\r\n    }\r\n\r\n    function setBootstrap(uint256 _bootstrapEpochs, uint256 _bootstrapSupplyExpansionPercent) external onlyOperator {\r\n        require(_bootstrapEpochs <= 120, \"_bootstrapEpochs: out of range\"); // <= 1 month\r\n        require(_bootstrapSupplyExpansionPercent >= 100 && _bootstrapSupplyExpansionPercent <= 1000, \"_bootstrapSupplyExpansionPercent: out of range\"); // [1%, 10%]\r\n        bootstrapEpochs = _bootstrapEpochs;\r\n        bootstrapSupplyExpansionPercent = _bootstrapSupplyExpansionPercent;\r\n    }\r\n    //======================================================================\r\n    function setExtraFunds(\r\n        address _daoFund,\r\n        uint256 _daoFundSharedPercent,\r\n        address _devFund,\r\n        uint256 _devFundSharedPercent,\r\n        address _teamFund,\r\n        uint256 _teamFundSharedPercent\r\n    ) external onlyOperator {\r\n        require(_daoFund != address(0), \"zero\");\r\n        require(_daoFundSharedPercent <= 1500, \"out of range\");\r\n        require(_devFund != address(0), \"zero\");\r\n        require(_devFundSharedPercent <= 350, \"out of range\");\r\n        require(_teamFund != address(0), \"zero\");\r\n        require(_teamFundSharedPercent <= 550, \"out of range\");\r\n\r\n        daoFund = _daoFund;\r\n        daoFundSharedPercent = _daoFundSharedPercent;\r\n        devFund = _devFund;\r\n        devFundSharedPercent = _devFundSharedPercent;\r\n        teamFund = _teamFund;\r\n        teamFundSharedPercent = _teamFundSharedPercent;\r\n    }\r\n\r\n    function setMaxDiscountRate(uint256 _maxDiscountRate) external onlyOperator {\r\n        require(_maxDiscountRate <= 20000, \"_maxDiscountRate is over 200%\");\r\n        maxDiscountRate = _maxDiscountRate;\r\n    }\r\n\r\n    function setMaxPremiumRate(uint256 _maxPremiumRate) external onlyOperator {\r\n        require(_maxPremiumRate <= 20000, \"_maxPremiumRate is over 200%\");\r\n        maxPremiumRate = _maxPremiumRate;\r\n    }\r\n\r\n    function setDiscountPercent(uint256 _discountPercent) external onlyOperator {\r\n        require(_discountPercent <= 20000, \"_discountPercent is over 200%\");\r\n        discountPercent = _discountPercent;\r\n    }\r\n\r\n    function setPremiumThreshold(uint256 _premiumThreshold) external onlyOperator {\r\n        require(_premiumThreshold >= basedPriceCeiling, \"_premiumThreshold exceeds basedPriceCeiling\");\r\n        require(_premiumThreshold <= 150, \"_premiumThreshold is higher than 1.5\");\r\n        premiumThreshold = _premiumThreshold;\r\n    }\r\n\r\n    function setPremiumPercent(uint256 _premiumPercent) external onlyOperator {\r\n        require(_premiumPercent <= 20000, \"_premiumPercent is over 200%\");\r\n        premiumPercent = _premiumPercent;\r\n    }\r\n\r\n    function setMintingFactorForPayingDebt(uint256 _mintingFactorForPayingDebt) external onlyOperator {\r\n        require(_mintingFactorForPayingDebt >= 10000 && _mintingFactorForPayingDebt <= 20000, \"_mintingFactorForPayingDebt: out of range\"); // [100%, 200%]\r\n        mintingFactorForPayingDebt = _mintingFactorForPayingDebt;\r\n    }\r\n\r\n    /* ========== MUTABLE FUNCTIONS ========== */\r\n\r\n    function _updateBasedPrice() internal {\r\n        try IOracle(basedOracle).update() {} catch {}\r\n    }\r\n\r\n    function getBasedCirculatingSupply() public view returns (uint256) {\r\n        IERC20 basedErc20 = IERC20(based);\r\n        uint256 totalSupply = basedErc20.totalSupply();\r\n        uint256 balanceExcluded = 0;\r\n        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\r\n            balanceExcluded = balanceExcluded.add(basedErc20.balanceOf(excludedFromTotalSupply[entryId]));\r\n        }\r\n        return totalSupply.sub(balanceExcluded);\r\n    }\r\n\r\n    function buyBonds(uint256 _basedAmount, uint256 targetPrice) external onlyOneBlock checkCondition checkOperator {\r\n        require(_basedAmount > 0, \"Treasury: cannot purchase bonds with zero amount\");\r\n\r\n        uint256 basedPrice = getBasedPrice();\r\n        require(basedPrice == targetPrice, \"Treasury: BASED price moved\");\r\n        require(\r\n            basedPrice < basedPriceOne, // price < $1\r\n            \"Treasury: basedPrice not eligible for bond purchase\"\r\n        );\r\n\r\n        require(_basedAmount <= epochSupplyContractionLeft, \"Treasury: not enough bond left to purchase\");\r\n\r\n        uint256 _rate = getBondDiscountRate();\r\n        require(_rate > 0, \"Treasury: invalid bond rate\");\r\n\r\n        uint256 _bondAmount = _basedAmount.mul(_rate).div(1e18);\r\n        uint256 basedSupply = getBasedCirculatingSupply();\r\n        uint256 newBondSupply = IERC20(bbond).totalSupply().add(_bondAmount);\r\n        require(newBondSupply <= basedSupply.mul(maxDebtRatioPercent).div(10000), \"over max debt ratio\");\r\n\r\n        IBasisAsset(based).burnFrom(msg.sender, _basedAmount);\r\n        IBasisAsset(bbond).mint(msg.sender, _bondAmount);\r\n\r\n        epochSupplyContractionLeft = epochSupplyContractionLeft.sub(_basedAmount);\r\n        _updateBasedPrice();\r\n\r\n        emit BoughtBonds(msg.sender, _basedAmount, _bondAmount);\r\n    }\r\n\r\n    function redeemBonds(uint256 _bondAmount, uint256 targetPrice) external onlyOneBlock checkCondition checkOperator {\r\n        require(_bondAmount > 0, \"Treasury: cannot redeem bonds with zero amount\");\r\n\r\n        uint256 basedPrice = getBasedPrice();\r\n        require(basedPrice == targetPrice, \"Treasury: BASED price moved\");\r\n        require(\r\n            basedPrice > basedPriceCeiling, // price > $1.01\r\n            \"Treasury: basedPrice not eligible for bond purchase\"\r\n        );\r\n\r\n        uint256 _rate = getBondPremiumRate();\r\n        require(_rate > 0, \"Treasury: invalid bond rate\");\r\n\r\n        uint256 _basedAmount = _bondAmount.mul(_rate).div(1e18);\r\n        require(IERC20(based).balanceOf(address(this)) >= _basedAmount, \"Treasury: treasury has no more budget\");\r\n\r\n        seigniorageSaved = seigniorageSaved.sub(Math.min(seigniorageSaved, _basedAmount));\r\n\r\n        IBasisAsset(bbond).burnFrom(msg.sender, _bondAmount);\r\n        IERC20(based).safeTransfer(msg.sender, _basedAmount);\r\n\r\n        _updateBasedPrice();\r\n\r\n        emit RedeemedBonds(msg.sender, _basedAmount, _bondAmount);\r\n    }\r\n\r\n    function _sendToAcropolis(uint256 _amount) internal {\r\n        IBasisAsset(based).mint(address(this), _amount);\r\n\r\n        uint256 _daoFundSharedAmount = 0;\r\n        if (daoFundSharedPercent > 0) {\r\n            _daoFundSharedAmount = _amount.mul(daoFundSharedPercent).div(10000);\r\n            IERC20(based).transfer(daoFund, _daoFundSharedAmount);\r\n            emit DaoFundFunded(block.timestamp, _daoFundSharedAmount);\r\n        }\r\n\r\n        uint256 _devFundSharedAmount = 0;\r\n        if (devFundSharedPercent > 0) {\r\n            _devFundSharedAmount = _amount.mul(devFundSharedPercent).div(10000);\r\n            IERC20(based).transfer(devFund, _devFundSharedAmount);\r\n            emit DevFundFunded(block.timestamp, _devFundSharedAmount);\r\n        }\r\n\r\n        uint256 _teamFundSharedAmount = 0;\r\n        if (teamFundSharedPercent > 0) {\r\n            _teamFundSharedAmount = _amount.mul(teamFundSharedPercent).div(10000);\r\n            IERC20(based).transfer(teamFund, _teamFundSharedAmount);\r\n            emit TeamFundFunded(block.timestamp, _teamFundSharedAmount);\r\n        }\r\n\r\n        _amount = _amount.sub(_daoFundSharedAmount).sub(_devFundSharedAmount).sub(_teamFundSharedAmount);\r\n\r\n        IERC20(based).safeApprove(acropolis, 0);\r\n        IERC20(based).safeApprove(acropolis, _amount);\r\n        IAcropolis(acropolis).allocateSeigniorage(_amount);\r\n        emit AcropolisFunded(block.timestamp, _amount);\r\n    }\r\n\r\n    function _calculateMaxSupplyExpansionPercent(uint256 _basedSupply) internal returns (uint256) {\r\n        for (uint8 tierId = 6; tierId >= 0; --tierId) {\r\n            if (_basedSupply >= supplyTiers[tierId]) {\r\n                maxSupplyExpansionPercent = maxExpansionTiers[tierId];\r\n                break;\r\n            }\r\n        }\r\n        return maxSupplyExpansionPercent;\r\n    }\r\n\r\n    function allocateSeigniorage() external onlyOneBlock checkCondition checkEpoch checkOperator {\r\n        _updateBasedPrice();\r\n        previousEpochBasedPrice = getBasedPrice();\r\n        uint256 basedSupply = getBasedCirculatingSupply().sub(seigniorageSaved);\r\n        if (epoch < bootstrapEpochs) {\r\n            // 14 first epochs with 6% expansion\r\n            _sendToAcropolis(basedSupply.mul(bootstrapSupplyExpansionPercent).div(10000));\r\n        } else {\r\n            if (previousEpochBasedPrice > basedPriceCeiling) {\r\n                // Expansion ($BASED Price > 1 $FTM): there is some seigniorage to be allocated\r\n                uint256 bondSupply = IERC20(bbond).totalSupply();\r\n                uint256 _percentage = previousEpochBasedPrice.sub(basedPriceOne);\r\n                uint256 _savedForBond;\r\n                uint256 _savedForAcropolis;\r\n                uint256 _mse = _calculateMaxSupplyExpansionPercent(basedSupply).mul(1e14);\r\n                if (_percentage > _mse) {\r\n                    _percentage = _mse;\r\n                }\r\n                if (seigniorageSaved >= bondSupply.mul(bondDepletionFloorPercent).div(10000)) {\r\n                    // saved enough to pay debt, mint as usual rate\r\n                    _savedForAcropolis = basedSupply.mul(_percentage).div(1e18);\r\n                } else {\r\n                    // have not saved enough to pay debt, mint more\r\n                    uint256 _seigniorage = basedSupply.mul(_percentage).div(1e18);\r\n                    _savedForAcropolis = _seigniorage.mul(seigniorageExpansionFloorPercent).div(10000);\r\n                    _savedForBond = _seigniorage.sub(_savedForAcropolis);\r\n                    if (mintingFactorForPayingDebt > 0) {\r\n                        _savedForBond = _savedForBond.mul(mintingFactorForPayingDebt).div(10000);\r\n                    }\r\n                }\r\n                if (_savedForAcropolis > 0) {\r\n                    _sendToAcropolis(_savedForAcropolis);\r\n                }\r\n                if (_savedForBond > 0) {\r\n                    seigniorageSaved = seigniorageSaved.add(_savedForBond);\r\n                    IBasisAsset(based).mint(address(this), _savedForBond);\r\n                    emit TreasuryFunded(block.timestamp, _savedForBond);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //===================================================================================================================================\r\n\r\n    function governanceRecoverUnsupported(\r\n        IERC20 _token,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyOperator {\r\n        // do not allow to drain core tokens\r\n        require(address(_token) != address(based), \"based\");\r\n        require(address(_token) != address(bbond), \"bond\");\r\n        require(address(_token) != address(bshare), \"share\");\r\n        _token.safeTransfer(_to, _amount);\r\n    }\r\n\r\n    function acropolisSetOperator(address _operator) external onlyOperator {\r\n        IAcropolis(acropolis).setOperator(_operator);\r\n    }\r\n\r\n    function acropolisSetLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external onlyOperator {\r\n        IAcropolis(acropolis).setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\r\n    }\r\n\r\n    function acropolisAllocateSeigniorage(uint256 amount) external onlyOperator {\r\n        IAcropolis(acropolis).allocateSeigniorage(amount);\r\n    }\r\n\r\n    function acropolisGovernanceRecoverUnsupported(\r\n        address _token,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyOperator {\r\n        IAcropolis(acropolis).governanceRecoverUnsupported(_token, _amount, _to);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/lib/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Babylonian {\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n        // else z = 0\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOracle {\r\n    function update() external;\r\n\r\n    function consult(address _token, uint256 _amountIn) external view returns (uint144 amountOut);\r\n\r\n    function twap(address _token, uint256 _amountIn) external view returns (uint144 _amountOut);\r\n}\r\n"
    },
    "contracts/interfaces/IAcropolis.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IAcropolis {\r\n    function balanceOf(address _andras) external view returns (uint256);\r\n\r\n    function earned(address _andras) external view returns (uint256);\r\n\r\n    function canWithdraw(address _andras) external view returns (bool);\r\n\r\n    function canClaimReward(address _andras) external view returns (bool);\r\n\r\n    function epoch() external view returns (uint256);\r\n\r\n    function nextEpochPoint() external view returns (uint256);\r\n\r\n    function getTombPrice() external view returns (uint256);\r\n\r\n    function setOperator(address _operator) external;\r\n\r\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\r\n\r\n    function stake(uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n\r\n    function exit() external;\r\n\r\n    function claimReward() external;\r\n\r\n    function allocateSeigniorage(uint256 _amount) external;\r\n\r\n    function governanceRecoverUnsupported(address _token, uint256 _amount, address _to) external;\r\n}\r\n"
    },
    "contracts/BShareSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./interfaces/ITreasury.sol\";\r\nimport \"./interfaces/IZapper.sol\";\r\n\r\nimport \"./owner/Operator.sol\";\r\n\r\ncontract BShareSwapper is Operator {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    address public based;\r\n    address public bshare;\r\n    address public bbond;\r\n\r\n    address public basedOracle;\r\n    address public bshareOracle;\r\n    address public treasury;\r\n    address public zapper;\r\n\r\n    \r\n\r\n    mapping (address => bool) public useNativeRouter;\r\n\r\n    event BBondSwapPerformed(address indexed sender, uint256 bbondAmount, uint256 bshareAmount);\r\n\r\n\r\n    constructor(\r\n        address _based,\r\n        address _bbond,\r\n        address _bshare,\r\n        address _basedOracle,\r\n        address _bshareOracle,\r\n        address _treasury,\r\n        address _zapper\r\n    ) {\r\n        based = _based;\r\n        bbond = _bbond;\r\n        bshare = _bshare;\r\n        basedOracle = _basedOracle;\r\n        bshareOracle = _bshareOracle;\r\n        treasury = _treasury;\r\n        zapper = _zapper;\r\n    }\r\n   modifier whitelist(address route) {\r\n        require(useNativeRouter[route], \"route not allowed\");\r\n        _;\r\n    }\r\n\r\n     function _approveTokenIfNeeded(address token, address router) private {\r\n        if (IERC20(token).allowance(address(this), router) == 0) {\r\n            IERC20(token).safeApprove(router, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    function getBasedPrice() public view returns (uint256 basedPrice) {\r\n        try IOracle(basedOracle).consult(based, 1e18) returns (uint144 price) {\r\n            return uint256(price);\r\n        } catch {\r\n            revert(\"Treasury: failed to consult BASED price from the oracle\");\r\n        }\r\n    }\r\n    function getBsharePrice() public view returns (uint256 bsharePrice) {\r\n        try IOracle(bshareOracle).consult(bshare, 1e18) returns (uint144 price) {\r\n            return uint256(price);\r\n        } catch {\r\n            revert(\"Treasury: failed to consult BSHARE price from the oracle\");\r\n        }\r\n    }\r\n    function redeemBonds(uint256 _bbondAmount, uint256 basedPrice) private returns (uint256) {\r\n\r\n         IERC20(bbond).safeTransferFrom(msg.sender, address(this), _bbondAmount);\r\n         _approveTokenIfNeeded(bbond, treasury);\r\n       \r\n        try ITreasury(treasury).redeemBonds(_bbondAmount, basedPrice) {\r\n        } catch {\r\n            revert(\"Treasury: cant redeem bonds\");\r\n        }\r\n        return getBasedBalance();\r\n    }\r\n\r\n    function swap(address _in, uint256 amount, address out, address recipient, address routerAddr, uint256 minAmountOfBshare) private returns (uint256) {\r\n        \r\n        IERC20(based).safeTransferFrom(address(this), zapper, amount);\r\n        _approveTokenIfNeeded(based, routerAddr);\r\n        \r\n         try IZapper(zapper)._swap(_in, amount, out, recipient, routerAddr , minAmountOfBshare) returns (uint256 _bshareAmount) {\r\n             require( _bshareAmount >= minAmountOfBshare, \"amt < minAmountNeeded\");\r\n            return uint256(_bshareAmount);\r\n        } catch {\r\n            revert(\"Treasury: failed to get BSHARE price\");\r\n        }\r\n    }\r\n   \r\n\r\n    function estimateAmountOfBShare(uint256 _bbondAmount) external view returns (uint256) {\r\n        uint256 bshareAmountPerBased = getBShareAmountPerBased();\r\n        return _bbondAmount.mul(bshareAmountPerBased).div(1e18);\r\n    }\r\n\r\n    function swapBBondToBShare(uint256 _bbondAmount, address routerAddr, uint256 minAmountofBshare) external whitelist(routerAddr) {\r\n        //check if we have the amount of bbonds we want to swap\r\n        require(getBBondBalance(msg.sender) >= _bbondAmount, \"Not enough BBond in wallet\");\r\n        \r\n       // send bbond to treasury(call redeem bonds in treasury) and receive based back\r\n        uint256 basedPrice = getBasedPrice();\r\n        uint256 basedToSwap = redeemBonds(_bbondAmount, basedPrice);\r\n       // check if we received based(should be more than bbonds because of higher rate in redeem in treasury)\r\n       require ( basedToSwap >= _bbondAmount, \"redeem bonds reverted\"); \r\n       // swap based to bshare\r\n        uint256 bshareReceived = swap(based, basedToSwap, bshare, msg.sender, routerAddr, minAmountofBshare);\r\n\r\n        emit BBondSwapPerformed(msg.sender, _bbondAmount, bshareReceived);\r\n    }\r\n\r\n\r\n    function getBasedBalance() public view returns (uint256) {\r\n        return IERC20(based).balanceOf(address(this));\r\n    }\r\n    function getBShareBalance() public view returns (uint256) {\r\n        return IERC20(bshare).balanceOf(address(this));\r\n    }\r\n\r\n    function getBBondBalance(address _user) public view returns (uint256) {\r\n        return IERC20(bbond).balanceOf(_user);\r\n    }\r\n    \r\n    function getBShareAmountPerBased() public view returns (uint256) {\r\n        uint256 basedPrice = getBasedPrice();\r\n        uint256 bsharePrice = getBsharePrice();\r\n        return basedPrice.mul(1e18).div(bsharePrice);\r\n    }\r\n    function setUseNativeRouter(address router) external onlyOwner {\r\n        useNativeRouter[router] = true;\r\n    }\r\n\r\n    function removeNativeRouter(address router) external onlyOwner {\r\n        useNativeRouter[router] = false;\r\n    }\r\n\r\n}"
    },
    "contracts/interfaces/IZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IZapper {\r\n    function _swap(address _in, uint256 amount, address out, address recipient, address routerAddr, uint256 slippage) external returns (uint256);\r\n\r\n    function _estimateSwap(address _in, uint256 amount, address out, address routerAddr) external view returns (uint256);\r\n\r\n}\r\n"
    },
    "contracts/Zapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IHyperswapRouter.sol\";\r\nimport \"./interfaces/IUniswapV2Pair.sol\";\r\nimport \"./interfaces/IUniswapV2Router.sol\";\r\nimport \"./interfaces/IVault.sol\";\r\nimport \"./lib/TransferHelper.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Zapper is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    // @NATIVE - native token that is not a part of our zap-in LP\r\n    address private NATIVE;\r\n\r\n    struct LiquidityPair {\r\n        address _token0;\r\n        address _token1;\r\n        uint256 _amountToken0;\r\n        uint256 _amountToken1;\r\n        uint256 _liqTokenAmt;\r\n    }\r\n\r\n    struct FunctionArgs {\r\n        address _LP;\r\n        address _in;\r\n        address _out;\r\n        address _recipient;\r\n        address _routerAddr;\r\n        address _token;\r\n        uint256 _amount;\r\n        \r\n        uint256 _otherAmt;\r\n        uint256 _swapAmt;\r\n    }\r\n\r\n    mapping(address => mapping(address => address)) private tokenBridgeForRouter;\r\n\r\n    mapping (address => bool) public useNativeRouter;\r\n\r\n    modifier whitelist(address route) {\r\n        require(useNativeRouter[route], \"route not allowed\");\r\n        _;\r\n    }\r\n\r\n    // Based address here\r\n    constructor(address _NATIVE) Ownable() {\r\n        NATIVE = _NATIVE;\r\n    }\r\n\r\n    /* ========== External Functions ========== */\r\n\r\n    receive() external payable {}\r\n\r\n    function NativeToken() public view returns (address) {\r\n        return NATIVE;\r\n    }\r\n\r\n    // @_in - Token we want to throw in\r\n    // @amount - amount of our _in\r\n    // @out - address of LP we are going to get\r\n    // @minAmountOfLp - will be calculated on UI including slippage set by user\r\n\r\n    function zapInToken(address _in, uint256 amount, address out, address routerAddr, address recipient, uint256 minAmountOfLp) external whitelist(routerAddr) {\r\n        // From an ERC20 to an LP token, through specified router, going through base asset if necessary\r\n        IERC20(_in).safeTransferFrom(msg.sender, address(this), amount);\r\n        // we'll need this approval to add liquidity\r\n        _approveTokenIfNeeded(_in, routerAddr);\r\n       uint256 amountOfLp =  _swapTokenToLP(_in, amount, out, recipient, routerAddr);\r\n        // add require after actual actioin of all functions - will revert lp creation if doesnt meet requirement\r\n        require(amountOfLp >= minAmountOfLp, \"lp amount too small\");\r\n    }\r\n    // @_in - Token we want to throw in\r\n    // @amount - amount of our _in\r\n    // @out - address of LP we are going to get\r\n\r\n    function estimateZapInToken(address _in, address out, address router, uint256 amount) public view whitelist(router) returns (uint256, uint256) {\r\n        // get pairs for desired lp\r\n        // check if we already have one of the assets\r\n        if (_in == IUniswapV2Pair(out).token0() || _in == IUniswapV2Pair(out).token1()) {\r\n            // if so, we're going to sell half of in for the other token we need\r\n            // figure out which token we need, and approve\r\n            address other = _in == IUniswapV2Pair(out).token0() ? IUniswapV2Pair(out).token1() : IUniswapV2Pair(out).token0();\r\n            // calculate amount of in to sell\r\n            uint256 sellAmount = amount.div(2);\r\n            // calculate amount of other token for potential lp\r\n            uint256 otherAmount = _estimateSwap(_in, sellAmount, other, router);\r\n            if (_in == IUniswapV2Pair(out).token0()) {\r\n                return (sellAmount, otherAmount);\r\n            } else {\r\n                return (otherAmount, sellAmount);\r\n            }\r\n        } else {\r\n            // go through native token, that's not in our LP, for highest liquidity\r\n            uint256 nativeAmount = _in == NATIVE ? amount : _estimateSwap(_in, amount, NATIVE, router);\r\n            return estimateZapIn(out, router, nativeAmount);\r\n        }\r\n    }\r\n\r\n    function estimateZapIn(address LP, address router, uint256 amount) public view whitelist(router) returns (uint256, uint256) {\r\n        uint256 zapAmount = amount.div(2);\r\n\r\n        IUniswapV2Pair pair = IUniswapV2Pair(LP);\r\n        address token0 = pair.token0();\r\n        address token1 = pair.token1();\r\n\r\n        if (token0 == NATIVE || token1 == NATIVE) {\r\n            address token = token0 == NATIVE ? token1 : token0;\r\n            uint256 tokenAmount = _estimateSwap(NATIVE, zapAmount, token, router);\r\n            if (token0 == NATIVE) {\r\n                return (zapAmount, tokenAmount);\r\n            } else {\r\n                return (tokenAmount, zapAmount);\r\n            }\r\n        } else {\r\n            uint256 amountToken0 = _estimateSwap(NATIVE, zapAmount, token0, router);\r\n            uint256 amountToken1 = _estimateSwap(NATIVE, zapAmount, token1, router);\r\n\r\n            return (amountToken0, amountToken1);\r\n        }\r\n    }\r\n\r\n    // from Native to an LP token through the specified router\r\n    // @ out - LP we want to get out of this\r\n    // @ minAmountOfLp will be calculated on UI using estimate function and passed into this function\r\n    function nativeZapIn(uint256 amount, address out, address routerAddr, address recipient, uint256 minAmountOfLp) external whitelist (routerAddr) {\r\n         IERC20(NATIVE).safeTransferFrom(msg.sender, address(this), amount);\r\n         _approveTokenIfNeeded(NATIVE, routerAddr);\r\n        uint256 amountOfLp = _swapNativeToLP(out, amount, recipient, routerAddr);\r\n        require(amountOfLp >= minAmountOfLp);\r\n    }\r\n\r\n     // @ _fromLP - LP we want to throw in\r\n    // @ _to - token we want to get out of our LP\r\n    // @ minAmountToken0, minAmountToken1 - coming from UI (min amount of tokens coming from breaking our LP)\r\n    function estimateZapOutToken(address _fromLp, address _to, address _router, uint256 minAmountToken0, uint256 minAmountToken1 ) public view whitelist(_router) returns (uint256) {\r\n        address token0 = IUniswapV2Pair(_fromLp).token0();\r\n        address token1 = IUniswapV2Pair(_fromLp).token1();\r\n        if(_to == NATIVE) {\r\n            if(token0 == NATIVE) {\r\n                return _estimateSwap(token1, minAmountToken1, _to, _router).add(minAmountToken0);\r\n            } else {\r\n                return _estimateSwap(token0, minAmountToken0, _to, _router).add(minAmountToken1);\r\n            }\r\n        }\r\n\r\n        if(token0 == NATIVE) {\r\n\r\n            if(_to == token1) {\r\n               \r\n                return _estimateSwap(token0, minAmountToken0, _to, _router).add(minAmountToken1);\r\n\r\n            } else {\r\n               \r\n                uint256 halfAmountof_to = _estimateSwap(token0, minAmountToken0, _to, _router);\r\n                uint256 otherhalfAmountof_to = _estimateSwap(token1, minAmountToken1, _to, _router);\r\n                return (halfAmountof_to.add(otherhalfAmountof_to));\r\n            }\r\n        } else {\r\n            if (_to == token0) {\r\n              \r\n                return _estimateSwap(token1, minAmountToken1, _to, _router).add(minAmountToken0);\r\n\r\n            } else {\r\n              \r\n                uint256 halfAmountof_to = _estimateSwap(token0, minAmountToken0, _to, _router);\r\n                uint256 otherhalfAmountof_to = _estimateSwap(token1, minAmountToken1, _to, _router);\r\n                return halfAmountof_to.add(otherhalfAmountof_to);\r\n            }\r\n        }\r\n    }\r\n\r\n    // from an LP token to Native through specified router\r\n    // @in - LP we want to throw in\r\n    // @amount - amount of our LP\r\n    function zapOutToNative(address _in, uint256 amount, address routerAddr, address recipient, uint256 minAmountNative) external whitelist(routerAddr) {\r\n        // take the LP token\r\n        IERC20(_in).safeTransferFrom(msg.sender, address(this), amount);\r\n        _approveTokenIfNeeded(_in, routerAddr);\r\n\r\n        LiquidityPair memory pair;\r\n\r\n        // get pairs for LP\r\n        pair._token0 = IUniswapV2Pair(_in).token0();\r\n        pair._token1 = IUniswapV2Pair(_in).token1();\r\n        _approveTokenIfNeeded(pair._token0, routerAddr);\r\n        _approveTokenIfNeeded(pair._token1, routerAddr);\r\n\r\n\r\n        (pair._amountToken0, pair._amountToken1) = IUniswapV2Router(routerAddr).removeLiquidity(pair._token0, pair._token1, amount, 0, 0, address(this), block.timestamp);\r\n        if (pair._token0 != NATIVE) {\r\n            pair._amountToken0 = _swapTokenForNative(pair._token0, pair._amountToken0, address(this), routerAddr);\r\n        }\r\n        if (pair._token1 != NATIVE) {\r\n            pair._amountToken1 = _swapTokenForNative(pair._token1, pair._amountToken1, address(this), routerAddr);\r\n        }\r\n        require (pair._amountToken0.add(pair._amountToken1) >= minAmountNative, \"token amt < minAmountNative\");\r\n        IERC20(NATIVE).safeTransfer(recipient, pair._amountToken0.add(pair._amountToken1));\r\n\r\n    }\r\n    // from an LP token to an ERC20 through specified router\r\n\r\n    // from an LP token to Native through specified router\r\n    // @in - LP we want to throw in\r\n    // @amount - amount of our LP\r\n    // @out - token we want to get\r\n    function zapOutToToken(address _in, uint256 amount, address out, address routerAddr, address recipient, uint256 minAmountToken) whitelist(routerAddr) external {\r\n\r\n        FunctionArgs memory args;\r\n        LiquidityPair memory pair;\r\n\r\n        args._amount = amount;\r\n        args._out = out;\r\n        args._recipient = recipient;\r\n        args._routerAddr = routerAddr;\r\n        \r\n        args._in = _in;\r\n\r\n        IERC20(args._in).safeTransferFrom(msg.sender, address(this), args._amount);\r\n        _approveTokenIfNeeded(args._in, args._routerAddr);\r\n\r\n        pair._token0 = IUniswapV2Pair(args._in).token0();\r\n        pair._token1 = IUniswapV2Pair(args._in).token1();\r\n\r\n        _approveTokenIfNeeded(pair._token0, args._routerAddr);\r\n        _approveTokenIfNeeded(pair._token1, args._routerAddr);\r\n\r\n        (pair._amountToken0, pair._amountToken1) = IUniswapV2Router(args._routerAddr).removeLiquidity(pair._token0, pair._token1, args._amount, 0, 0, address(this), block.timestamp);\r\n        if (pair._token0 != args._out) {\r\n            pair._amountToken0 = _swap(pair._token0, pair._amountToken0, args._out, address(this), args._routerAddr);\r\n        }\r\n        if (pair._token1 != args._out) {\r\n            pair._amountToken1 = _swap(pair._token1, pair._amountToken1, args._out, address(this), args._routerAddr);\r\n        }\r\n        require (pair._amountToken0.add(pair._amountToken1) >= minAmountToken, \"amt < minAmountToken\");\r\n        IERC20(args._out).safeTransfer(args._recipient, pair._amountToken0.add(pair._amountToken1));\r\n    }\r\n   \r\n    \r\n    // @_in - token we want to throw in\r\n    // @amount - amount of our _in\r\n    // @out - token we want to get out\r\n    function _swap(address _in, uint256 amount, address out, address recipient, address routerAddr) public whitelist(routerAddr) returns (uint256) {\r\n        IUniswapV2Router router = IUniswapV2Router(routerAddr);\r\n\r\n        address fromBridge = tokenBridgeForRouter[_in][routerAddr];\r\n        address toBridge = tokenBridgeForRouter[out][routerAddr];\r\n\r\n        address[] memory path;\r\n\r\n        if (fromBridge != address(0) && toBridge != address(0)) {\r\n            if (fromBridge != toBridge) {\r\n                path = new address[](5);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = NATIVE;\r\n                path[3] = toBridge;\r\n                path[4] = out;\r\n            } else {\r\n                path = new address[](3);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = out;\r\n            }\r\n        } else if (fromBridge != address(0)) {\r\n            if (out == NATIVE) {\r\n                path = new address[](3);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = NATIVE;\r\n            } else {\r\n                path = new address[](4);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = NATIVE;\r\n                path[3] = out;\r\n            }\r\n        } else if (toBridge != address(0)) {\r\n            path = new address[](4);\r\n            path[0] = _in;\r\n            path[1] = NATIVE;\r\n            path[2] = toBridge;\r\n            path[3] = out;\r\n        } else if (_in == NATIVE || out == NATIVE) {\r\n            path = new address[](2);\r\n            path[0] = _in;\r\n            path[1] = out;\r\n        } else {\r\n            // Go through Native\r\n            path = new address[](3);\r\n            path[0] = _in;\r\n            path[1] = NATIVE;\r\n            path[2] = out;\r\n        }\r\n        uint256 tokenAmountEst = _estimateSwap(_in, amount, out, routerAddr);\r\n\r\n        uint256[] memory amounts = router.swapExactTokensForTokens(amount, tokenAmountEst, path, recipient, block.timestamp);\r\n        require(amounts[amounts.length-1] >= tokenAmountEst, \"amount smaller than estimate\");\r\n        return amounts[amounts.length - 1];\r\n    }\r\n    // @_in - token we want to throw in\r\n    // @amount - amount of our _in\r\n    // @out - token we want to get out\r\n    function _estimateSwap(address _in, uint256 amount, address out, address routerAddr) public view whitelist(routerAddr) returns (uint256) {\r\n        IUniswapV2Router router = IUniswapV2Router(routerAddr);\r\n\r\n        address fromBridge = tokenBridgeForRouter[_in][routerAddr];\r\n        address toBridge = tokenBridgeForRouter[out][routerAddr];\r\n\r\n        address[] memory path;\r\n\r\n        if (fromBridge != address(0) && toBridge != address(0)) {\r\n            if (fromBridge != toBridge) {\r\n                path = new address[](5);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = NATIVE;\r\n                path[3] = toBridge;\r\n                path[4] = out;\r\n            } else {\r\n                path = new address[](3);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = out;\r\n            }\r\n        } else if (fromBridge != address(0)) {\r\n            if (out == NATIVE) {\r\n                path = new address[](3);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = NATIVE;\r\n            } else {\r\n                path = new address[](4);\r\n                path[0] = _in;\r\n                path[1] = fromBridge;\r\n                path[2] = NATIVE;\r\n                path[3] = out;\r\n            }\r\n        } else if (toBridge != address(0)) {\r\n            path = new address[](4);\r\n            path[0] = _in;\r\n            path[1] = NATIVE;\r\n            path[2] = toBridge;\r\n            path[3] = out;\r\n        } else if (_in == NATIVE || out == NATIVE) {\r\n            path = new address[](2);\r\n            path[0] = _in;\r\n            path[1] = out;\r\n        } else {\r\n            // Go through Native\r\n            path = new address[](3);\r\n            path[0] = _in;\r\n            path[1] = NATIVE;\r\n            path[2] = out;\r\n        }\r\n\r\n        uint256[] memory amounts = router.getAmountsOut(amount, path);\r\n        return amounts[amounts.length - 1];\r\n    }\r\n    /* ========== Private Functions ========== */\r\n\r\n    function _approveTokenIfNeeded(address token, address router) private {\r\n        if (IERC20(token).allowance(address(this), router) == 0) {\r\n            IERC20(token).safeApprove(router, type(uint256).max);\r\n        }\r\n    }\r\n    \r\n    function _swapTokenToLP(address _in, uint256 amount, address out, address recipient, address routerAddr) private returns (uint256) {\r\n       \r\n        FunctionArgs memory args;\r\n            args._in = _in;\r\n            args._amount = amount;\r\n            args._out = out;\r\n            args._recipient = recipient;\r\n            args._routerAddr = routerAddr;\r\n            \r\n        LiquidityPair memory pair;\r\n\r\n        if (args._in == IUniswapV2Pair(args._out).token0() || args._in == IUniswapV2Pair(args._out).token1()) { \r\n\r\n            args._token = args._in == IUniswapV2Pair(args._out).token0() ? IUniswapV2Pair(args._out).token1() : IUniswapV2Pair(args._out).token0();\r\n            // calculate args._amount of _in to sell\r\n            args._swapAmt = args._amount.div(2);\r\n            args._otherAmt = _swap(args._in, args._swapAmt, args._token, address(this), args._routerAddr);\r\n            _approveTokenIfNeeded(args._token, args._routerAddr);\r\n            // execute swap\r\n           \r\n            (pair._amountToken0 , pair._amountToken1 , pair._liqTokenAmt) = \r\n            IUniswapV2Router(args._routerAddr).addLiquidity(\r\n                args._in, \r\n                args._token, \r\n                args._amount.sub(args._swapAmt), \r\n                args._otherAmt, \r\n                args._swapAmt , \r\n                args._otherAmt, \r\n                args._recipient, \r\n                block.timestamp);\r\n            \r\n            if (args._in == IUniswapV2Pair(args._out).token0()) {\r\n                _dustDistribution(  args._swapAmt, \r\n                                    args._otherAmt, \r\n                                    pair._amountToken0, \r\n                                    pair._amountToken1, \r\n                                    args._in, \r\n                                    args._token, \r\n                                    args._recipient);\r\n\r\n            } else {\r\n                 _dustDistribution( args._otherAmt, \r\n                                    args._swapAmt, \r\n                                    pair._amountToken1, \r\n                                    pair._amountToken0, \r\n                                    args._in, \r\n                                    args._token, \r\n                                    args._recipient);\r\n            }\r\n            return pair._liqTokenAmt;\r\n        } else {\r\n            // go through native token for highest liquidity\r\n            uint256 nativeAmount = _swapTokenForNative(args._in, args._amount, address(this), args._routerAddr);\r\n            return _swapNativeToLP(args._out, nativeAmount, args._recipient, args._routerAddr);\r\n        }\r\n    }\r\n    \r\n    // @amount - amount of our native token\r\n    // @out - LP we want to get\r\n    function _swapNativeToLP(address out, uint256 amount, address recipient, address routerAddress) private returns (uint256) {\r\n        \r\n        IUniswapV2Pair pair = IUniswapV2Pair(out);\r\n        address token0 = pair.token0();  \r\n        address token1 = pair.token1();  \r\n        uint256 liquidity;\r\n\r\n        liquidity = _swapNativeToEqualTokensAndProvide(token0, token1, amount, routerAddress, recipient);\r\n        return liquidity;\r\n    }\r\n\r\n    function _dustDistribution(uint256 token0, uint256 token1, uint256 amountToken0, uint256 amountToken1, address native, address token, address recipient) private {\r\n        uint256 nativeDust = token0.sub(amountToken0);\r\n        uint256 tokenDust = token1.sub(amountToken1);\r\n        if (nativeDust > 0) {\r\n            IERC20(native).safeTransfer(recipient, nativeDust);\r\n        }\r\n        if (tokenDust > 0) {\r\n            IERC20(token).safeTransfer(recipient, tokenDust);\r\n        }\r\n\r\n    }\r\n    // @token0 - swap Native to this , and provide this to create LP\r\n    // @token1 - swap Native to this , and provide this to create LP\r\n    // @amount - amount of native token\r\n    function _swapNativeToEqualTokensAndProvide(address token0, address token1, uint256 amount, address routerAddress, address recipient) private returns (uint256) {\r\n        FunctionArgs memory args;\r\n        args._amount = amount;\r\n        args._recipient = recipient;\r\n        args._routerAddr = routerAddress;\r\n       \r\n        args._swapAmt = args._amount.div(2);\r\n\r\n        LiquidityPair memory pair;\r\n        pair._token0 = token0;\r\n        pair._token1 = token1;\r\n\r\n        IUniswapV2Router router = IUniswapV2Router(args._routerAddr);\r\n\r\n        if (pair._token0 == NATIVE) {\r\n            args._otherAmt= _swapNativeForToken(pair._token1, args._swapAmt, address(this), args._routerAddr);\r\n            _approveTokenIfNeeded(pair._token0, args._routerAddr);\r\n            _approveTokenIfNeeded(pair._token1, args._routerAddr);\r\n\r\n            (pair._amountToken0, pair._amountToken1, pair._liqTokenAmt) = \r\n            router.addLiquidity(    pair._token0, \r\n                                    pair._token1, \r\n                                    args._swapAmt, \r\n                                    args._otherAmt, \r\n                                    args._swapAmt, \r\n                                    args._otherAmt, \r\n                                    args._recipient, \r\n                                    block.timestamp);\r\n            _dustDistribution(  args._swapAmt, \r\n                                args._otherAmt, \r\n                                pair._amountToken0, \r\n                                pair._amountToken1, \r\n                                pair._token0, \r\n                                pair._token1, \r\n                                args._recipient);\r\n            return pair._liqTokenAmt;\r\n        } else {\r\n            args._otherAmt = _swapNativeForToken(pair._token0,  args._swapAmt, address(this), args._routerAddr);\r\n            _approveTokenIfNeeded( pair._token0, args._routerAddr);\r\n            _approveTokenIfNeeded( pair._token1, args._routerAddr);\r\n\r\n            (pair._amountToken0, pair._amountToken1, pair._liqTokenAmt) = \r\n            router.addLiquidity(pair._token0, \r\n                                pair._token1, \r\n                                args._otherAmt, \r\n                                args._swapAmt, \r\n                                args._otherAmt, \r\n                                args._swapAmt, \r\n                                args._recipient, \r\n                                block.timestamp);\r\n            _dustDistribution(  args._otherAmt, \r\n                                args._swapAmt, \r\n                                pair._amountToken1, \r\n                                pair._amountToken0,  \r\n                                pair._token1, \r\n                                pair._token0, \r\n                                args._recipient);\r\n            return pair._liqTokenAmt;\r\n        }\r\n    }\r\n    // @token - swap Native to this token\r\n    // @amount - amount of native token\r\n    function _swapNativeForToken(address token, uint256 amount, address recipient, address routerAddr) private returns (uint256) {\r\n        address[] memory path;\r\n        IUniswapV2Router router = IUniswapV2Router(routerAddr);\r\n\r\n        if (tokenBridgeForRouter[token][routerAddr] != address(0)) {\r\n            path = new address[](3);\r\n            path[0] = NATIVE;\r\n            path[1] = tokenBridgeForRouter[token][routerAddr];\r\n            path[2] = token;\r\n        } else {\r\n            path = new address[](2);\r\n            path[0] = NATIVE;\r\n            path[1] = token;\r\n        }\r\n        uint256 tokenAmt = _estimateSwap(NATIVE, amount, token, routerAddr);\r\n        uint256[] memory amounts = router.swapExactTokensForTokens(amount, tokenAmt, path, recipient, block.timestamp);\r\n        return amounts[amounts.length - 1];\r\n    }\r\n     // @token - swap this token to Native\r\n    // @amount - amount of native token\r\n    function _swapTokenForNative(address token, uint256 amount, address recipient, address routerAddr) private returns (uint256) {\r\n        address[] memory path;\r\n        IUniswapV2Router router = IUniswapV2Router(routerAddr);\r\n\r\n        if (tokenBridgeForRouter[token][routerAddr] != address(0)) {\r\n            path = new address[](3);\r\n            path[0] = token;\r\n            path[1] = tokenBridgeForRouter[token][routerAddr];\r\n            path[2] = NATIVE;\r\n        } else {\r\n            path = new address[](2);\r\n            path[0] = token;\r\n            path[1] = NATIVE;\r\n        }\r\n\r\n        uint256 tokenAmt = _estimateSwap(token, amount, NATIVE, routerAddr);\r\n        uint256[] memory amounts = router.swapExactTokensForTokens(amount, tokenAmt, path, recipient, block.timestamp);\r\n        return amounts[amounts.length - 1];\r\n    }\r\n\r\n      // @in - token we want to throw in\r\n    // @amount - amount of our token\r\n    // @out - token we want to get\r\n    function swapToken(address _in, uint256 amount, address out, address routerAddr, address _recipient, uint256 minAmountOut) private {\r\n        IERC20(_in).safeTransferFrom(msg.sender, address(this), amount);\r\n        _approveTokenIfNeeded(_in, routerAddr);\r\n       uint256 tokensOut =  _swap(_in, amount, out, _recipient, routerAddr);\r\n       require (tokensOut >= minAmountOut);\r\n    }\r\n    \r\n     // @in - token we want to throw in\r\n    // @amount - amount of our token\r\n    \r\n    function swapToNative(address _in, uint256 amount, address routerAddr, address _recipient, uint256 minAmountOut) private {\r\n        IERC20(_in).safeTransferFrom(msg.sender, address(this), amount);\r\n        _approveTokenIfNeeded(_in, routerAddr);\r\n        uint256 amountNative = _swapTokenForNative(_in, amount, _recipient, routerAddr);\r\n        require (amountNative >= minAmountOut);\r\n    }\r\n    \r\n   \r\n\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function setNativeToken(address _NATIVE) external onlyOwner {\r\n        NATIVE = _NATIVE;\r\n    }\r\n\r\n    function setTokenBridgeForRouter(address token, address router, address bridgeToken) external onlyOwner {\r\n        tokenBridgeForRouter[token][router] = bridgeToken;\r\n    }\r\n\r\n    function withdraw(address token) external onlyOwner {\r\n        if (token == address(0)) {\r\n            payable(owner()).transfer(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function setUseNativeRouter(address router) external onlyOwner {\r\n        useNativeRouter[router] = true;\r\n    }\r\n\r\n    function removeNativeRouter(address router) external onlyOwner {\r\n        useNativeRouter[router] = false;\r\n    }\r\n}"
    },
    "contracts/interfaces/IHyperswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IHyperswapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WFTM() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityFTM(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountFTMMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountFTM, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityFTM(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountFTMMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountFTM);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityFTMWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountFTMMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountFTM);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactFTMForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactFTM(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForFTM(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapFTMForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Router {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IVault is IERC20 {\r\n    function deposit(uint256 amount) external;\r\n    function withdraw(uint256 shares) external;\r\n    function want() external pure returns (address);\r\n}"
    },
    "contracts/lib/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}"
    },
    "contracts/Operator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Operator is Context, Ownable {\r\n    address private _operator;\r\n\r\n    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\r\n\r\n    constructor() {\r\n        _operator = _msgSender();\r\n        emit OperatorTransferred(address(0), _operator);\r\n    }\r\n\r\n    function operator() public view returns (address) {\r\n        return _operator;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(_operator == msg.sender, \"operator: caller is not the operator\");\r\n        _;\r\n    }\r\n\r\n    function isOperator() public view returns (bool) {\r\n        return _msgSender() == _operator;\r\n    }\r\n\r\n    function transferOperator(address newOperator_) public onlyOwner {\r\n        _transferOperator(newOperator_);\r\n    }\r\n\r\n    function _transferOperator(address newOperator_) internal {\r\n        require(newOperator_ != address(0), \"operator: zero address given for new operator\");\r\n        emit OperatorTransferred(address(0), newOperator_);\r\n        _operator = newOperator_;\r\n    }\r\n\r\n    function _renounceOperator() public onlyOwner {\r\n        emit OperatorTransferred(_operator, address(0));\r\n        _operator = address(0);\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/token/onft/IONFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\n/**\r\n * @dev Interface of the ONFT standard\r\n */\r\ninterface IONFT is IERC721 {\r\n    /**\r\n     * @dev send token `_tokenId` to (`_dstChainId`, `_toAddress`)\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParam` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function send(\r\n        uint16 _dstChainId,\r\n        bytes calldata _toAddress,\r\n        uint _tokenId,\r\n        address payable _refundAddress,\r\n        address _zroPaymentAddress,\r\n        bytes calldata _adapterParam\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParam` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(\r\n        address _from,\r\n        uint16 _dstChainId,\r\n        bytes calldata _toAddress,\r\n        uint _tokenId,\r\n        address payable _refundAddress,\r\n        address _zroPaymentAddress,\r\n        bytes calldata _adapterParam\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Emitted when `_tokenId` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\r\n     * `_nonce` is the outbound nonce from\r\n     */\r\n    event SendToChain(address indexed _sender, uint16 indexed _dstChainId, bytes indexed _toAddress, uint _tokenId, uint64 _nonce);\r\n\r\n    /**\r\n     * @dev Emitted when `_tokenId` are sent from `_srcChainId` to the `_toAddress` at this chain. `_nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(uint16 _srcChainId, address _toAddress, uint _tokenId, uint64 _nonce);\r\n}"
    },
    "contracts/token/onft/ONFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IONFT.sol\";\r\nimport \"../../lzApp/NonblockingLzApp.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\n// NOTE: this ONFT contract has no minting logic.\r\n// must implement your own minting logic in child classes\r\ncontract ONFT is IONFT, NonblockingLzApp, ERC721 {\r\n    string public baseTokenURI;\r\n\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC721(_name, _symbol) NonblockingLzApp(_lzEndpoint) {}\r\n\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParam) external payable virtual override {\r\n        _send(_from, _dstChainId, _toAddress, _tokenId, _refundAddress, _zroPaymentAddress, _adapterParam);\r\n    }\r\n\r\n    function send(uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParam) external payable virtual override {\r\n        _send(_msgSender(), _dstChainId, _toAddress, _tokenId, _refundAddress, _zroPaymentAddress, _adapterParam);\r\n    }\r\n\r\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParam) internal virtual {\r\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _beforeSend(_from, _dstChainId, _toAddress, _tokenId);\r\n\r\n        bytes memory payload = abi.encode(_toAddress, _tokenId);\r\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParam);\r\n\r\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\r\n        emit SendToChain(_from, _dstChainId, _toAddress, _tokenId, nonce);\r\n        _afterSend(_from, _dstChainId, _toAddress, _tokenId);\r\n    }\r\n\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        _beforeReceive(_srcChainId, _srcAddress, _payload);\r\n\r\n        // decode and load the toAddress\r\n        (bytes memory toAddress, uint tokenId) = abi.decode(_payload, (bytes, uint));\r\n        address localToAddress;\r\n        assembly {\r\n            localToAddress := mload(add(toAddress, 20))\r\n        }\r\n\r\n        // if the toAddress is 0x0, burn it or it will get cached\r\n        if (localToAddress == address(0x0)) localToAddress == address(0xdEaD);\r\n\r\n        _afterReceive(_srcChainId, localToAddress, tokenId);\r\n\r\n        emit ReceiveFromChain(_srcChainId, localToAddress, tokenId, _nonce);\r\n    }\r\n\r\n    function _beforeSend(address /* _from */, uint16 /* _dstChainId */, bytes memory /* _toAddress */, uint _tokenId) internal virtual {\r\n        _burn(_tokenId);\r\n    }\r\n\r\n    function _afterSend(address /* _from */, uint16 /* _dstChainId */, bytes memory /* _toAddress */, uint /* _tokenId */) internal virtual {}\r\n\r\n    function _beforeReceive(uint16 /* _srcChainId */, bytes memory /* _srcAddress */, bytes memory /* _payload */) internal virtual {}\r\n\r\n    function _afterReceive(uint16 /* _srcChainId */, address _toAddress, uint _tokenId) internal virtual {\r\n        _safeMint(_toAddress, _tokenId);\r\n    }\r\n\r\n    function setBaseURI(string memory _baseTokenURI) public onlyOwner {\r\n        baseTokenURI = _baseTokenURI;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n}"
    },
    "contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./LzApp.sol\";\r\n\r\n/*\r\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\r\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\r\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\r\n */\r\nabstract contract NonblockingLzApp is LzApp {\r\n    constructor(address _endpoint) LzApp(_endpoint) {}\r\n\r\n    mapping(uint16 => mapping(bytes => mapping(uint => bytes32))) public failedMessages;\r\n\r\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\r\n\r\n    // overriding the virtual function in LzReceiver\r\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        // try-catch all errors/exceptions\r\n        try this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\r\n            // do nothing\r\n        } catch {\r\n            // error / exception\r\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\r\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\r\n        }\r\n    }\r\n\r\n    function nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual {\r\n        // only internal transaction\r\n        require(_msgSender() == address(this), \"LzReceiver: caller must be Bridge.\");\r\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n\r\n    //@notice override this function\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\r\n\r\n    function retryMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes calldata _payload) external payable virtual {\r\n        // assert there is message to retry\r\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\r\n        require(payloadHash != bytes32(0), \"LzReceiver: no stored message\");\r\n        require(keccak256(_payload) == payloadHash, \"LzReceiver: invalid payload\");\r\n        // clear the stored message\r\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\r\n        // execute the message. revert if it fails again\r\n        this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n}"
    },
    "contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/ILayerZeroReceiver.sol\";\r\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\r\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\r\n\r\n/*\r\n * a generic LzReceiver implementation\r\n */\r\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\r\n    ILayerZeroEndpoint internal immutable lzEndpoint;\r\n\r\n    mapping(uint16 => bytes) internal trustedRemoteLookup;\r\n\r\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\r\n\r\n    constructor(address _endpoint) {\r\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\r\n    }\r\n\r\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) external override {\r\n        // lzReceive must be called by the endpoint for security\r\n        require(_msgSender() == address(lzEndpoint));\r\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\r\n        require(_srcAddress.length == trustedRemoteLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId]), \"LzReceiver: invalid source sending contract\");\r\n\r\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n\r\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\r\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\r\n\r\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParam) internal {\r\n        require(trustedRemoteLookup[_dstChainId].length != 0, \"LzSend: destination chain is not a trusted source.\");\r\n        lzEndpoint.send{value: msg.value}(_dstChainId, trustedRemoteLookup[_dstChainId], _payload, _refundAddress, _zroPaymentAddress, _adapterParam);\r\n    }\r\n\r\n    //---------------------------UserApplication config----------------------------------------\r\n    function getConfig(uint16, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\r\n        return lzEndpoint.getConfig(lzEndpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\r\n    }\r\n\r\n    // generic config for LayerZero user Application\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\r\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\r\n    }\r\n\r\n    function setSendVersion(uint16 _version) external override onlyOwner {\r\n        lzEndpoint.setSendVersion(_version);\r\n    }\r\n\r\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\r\n        lzEndpoint.setReceiveVersion(_version);\r\n    }\r\n\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\r\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    // allow owner to set it multiple times.\r\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\r\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\r\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\r\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\r\n        return keccak256(trustedSource) == keccak256(_srcAddress);\r\n    }\r\n\r\n    //--------------------------- VIEW FUNCTION ----------------------------------------\r\n    // interacting with the LayerZero Endpoint and remote contracts\r\n\r\n    function getTrustedRemote(uint16 _chainId) external view returns (bytes memory) {\r\n        return trustedRemoteLookup[_chainId];\r\n    }\r\n\r\n    function getLzEndpoint() external view returns (address) {\r\n        return address(lzEndpoint);\r\n    }\r\n}"
    },
    "contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroReceiver {\r\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\r\n    // @param _srcChainId - the source endpoint identifier\r\n    // @param _srcAddress - the source sending contract address from the source chain\r\n    // @param _nonce - the ordered message nonce\r\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\r\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\r\n}"
    },
    "contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroUserApplicationConfig {\r\n    // @notice set the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    // @param _config - configuration in the bytes. can encode arbitrary content.\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\r\n\r\n    // @notice set the send() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setSendVersion(uint16 _version) external;\r\n\r\n    // @notice set the lzReceive() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setReceiveVersion(uint16 _version) external;\r\n\r\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\r\n    // @param _srcChainId - the chainId of the source chain\r\n    // @param _srcAddress - the contract address of the source contract at the source chain\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\r\n}"
    },
    "contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\nimport \"./ILayerZeroUserApplicationConfig.sol\";\r\n\r\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\r\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\r\n    // @param _payload - a custom bytes payload to send to the destination contract\r\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\r\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\r\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\r\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    // @notice used by the messaging library to publish verified payload\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source contract (as bytes) at the source chain\r\n    // @param _dstAddress - the address on destination chain\r\n    // @param _nonce - the unbound message ordering nonce\r\n    // @param _gasLimit - the gas limit for external contract execution\r\n    // @param _payload - verified payload to send to the destination contract\r\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\r\n\r\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\r\n\r\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\r\n    // @param _srcAddress - the source chain contract address\r\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\r\n\r\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    // @param _payload - the custom message to send over LayerZero\r\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    // @notice get this Endpoint's immutable source identifier\r\n    function getChainId() external view returns (uint16);\r\n\r\n    // @notice the interface to retry failed message on this Endpoint destination\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    // @param _payload - the payload to be retried\r\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\r\n\r\n    // @notice query if any STORED payload (message blocking) at the endpoint.\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\r\n\r\n    // @notice query if the _libraryAddress is valid for sending msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the _libraryAddress is valid for receiving msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the non-reentrancy guard for send() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isSendingPayload() external view returns (bool);\r\n\r\n    // @notice query if the non-reentrancy guard for receive() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isReceivingPayload() external view returns (bool);\r\n\r\n    // @notice get the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _userApplication - the contract address of the user application\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\r\n\r\n    // @notice get the send() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getSendVersion(address _userApplication) external view returns (uint16);\r\n\r\n    // @notice get the lzReceive() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\r\n}"
    },
    "contracts/GodNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./token/onft/ONFT.sol\";\r\nimport \"./interfaces/IGodNFT.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract GodNFT is ONFT, IGodNFT {\r\n    uint public nextMintId;\r\n    uint public maxSupply;\r\n    address public managerAddress;\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == managerAddress, \"Only manager can call this function.\");\r\n        _;\r\n    }\r\n\r\n    /// @param _layerZeroEndpoint handles message transmission across chains\r\n    constructor(address _layerZeroEndpoint, uint _maxSupply) ONFT(\"GodNFT\", \"BNFT\", _layerZeroEndpoint) {\r\n        nextMintId = 0;\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n    /// @notice Mint your ONFT\r\n    function mintFor(address minter) external override onlyManager {\r\n        require(nextMintId <= maxSupply, \"ONFT: Max Mint limit reached\");\r\n\r\n        uint newId = nextMintId;\r\n        nextMintId++;\r\n\r\n        _safeMint(minter, newId);\r\n    }\r\n\r\n    function setManagerAddress(address _managerAddress) public onlyOwner {\r\n        managerAddress = _managerAddress;\r\n    }\r\n    function getTokenList(address account) external view returns (uint256[] memory) {\r\n        require(msg.sender != address(0));\r\n        require(account != address(0));\r\n\r\n        address selectedAccount = msg.sender;\r\n        if (owner() == msg.sender)\r\n            selectedAccount = account;\r\n\r\n        uint256 count = balanceOf(selectedAccount);\r\n        uint256[] memory tokenIdList = new uint256[](count);\r\n\r\n        if (count == 0)\r\n            return tokenIdList;\r\n\r\n        uint256 cnt = 0;\r\n        for (uint256 i = 0; i < nextMintId ; i++) {\r\n\r\n            if (_exists(i) && (ownerOf(i) == selectedAccount)) {\r\n                tokenIdList[cnt++] = i;\r\n            }\r\n\r\n            if (cnt == count)\r\n                break;\r\n        }\r\n\r\n        return tokenIdList;\r\n    }\r\n}"
    },
    "contracts/interfaces/IGodNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IGodNFT {\r\n    function mintFor(address minter) external;\r\n}"
    },
    "contracts/NFTStaker.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./GODtoken.sol\";\r\nimport \"./GodNFT.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract NFTStaker is Ownable, IERC721Receiver {\r\nusing SafeERC20 for IERC20;\r\n\r\n  uint256 public totalStaked;\r\n  IERC20 token;\r\n  IERC721 nft;\r\n\r\n // struct to store a stake's token, owner, and earning values\r\n  struct Staker {\r\n    uint256 timestamp;\r\n    address owner;\r\n  }\r\n\r\n  mapping(uint256 => Staker) public stakers; \r\n  // Enumeration\r\n  mapping(address => mapping(uint256 => uint256)) public ownedStakes; // (address, index) => tokenid\r\n  mapping(uint256 => uint256) public ownedStakesIndex; // tokenId => index in its owner's stake list\r\n  mapping (address => uint256) public ownedStakesBalance;\r\n\r\n   constructor(address _nft, address _token) { \r\n    nft = IERC721(_nft);\r\n    token = IERC20(_token);\r\n  }\r\n\r\n   receive() external payable {}\r\n\r\n  function stake(uint256[] calldata tokenIds) external {\r\n    uint256 tokenId;\r\n    address _owner = msg.sender;\r\n    totalStaked += tokenIds.length;\r\n    for (uint i = 0; i < tokenIds.length; i++) {\r\n      tokenId = tokenIds[i];\r\n      require(nft.ownerOf(tokenId) == msg.sender, \"not your token\");\r\n      require(stakers[tokenId].timestamp == 0, \"already staked\");\r\n\r\n      stakers[tokenId] = Staker({\r\n        owner: _owner,\r\n        timestamp: uint256(block.timestamp)\r\n      });\r\n      \r\n      uint256 length = ownedStakesBalance[_owner];\r\n      ownedStakes[_owner][length] = tokenId;\r\n      ownedStakesIndex[tokenId] = length;\r\n      ownedStakesBalance[_owner]++;\r\n      \r\n      nft.transferFrom(msg.sender, address(this), tokenId);\r\n      token.safeTransfer(msg.sender, 1);\r\n    }\r\n  }\r\n\r\n  function unstake(address _staker, uint256[] calldata tokenIds) external {\r\n    uint256 tokenId;\r\n    address _owner = msg.sender;\r\n    totalStaked -= tokenIds.length;\r\n      require(token.balanceOf(msg.sender) >= tokenIds.length, \"not enough GODS tokens\");\r\n    for (uint i = 0; i < tokenIds.length; i++) {\r\n      tokenId = tokenIds[i];\r\n      Staker memory staked = stakers[tokenId];\r\n      require(staked.owner == msg.sender, \"not an owner\");\r\n    \r\n      delete stakers[tokenId];\r\n\r\n      uint256 lastTokenIndex = ownedStakesBalance[_owner] - 1;\r\n      uint256 tokenIndex = ownedStakesIndex[tokenId];\r\n\r\n      if (tokenIndex != lastTokenIndex) {\r\n          uint256 lastTokenId = ownedStakes[_owner][lastTokenIndex];\r\n          ownedStakes[_owner][tokenIndex] = lastTokenId;\r\n          ownedStakesIndex[lastTokenId] = tokenIndex;\r\n      }\r\n\r\n      delete ownedStakesIndex[tokenId];\r\n      delete ownedStakes[_owner][lastTokenIndex];\r\n\r\n      ownedStakesBalance[msg.sender]--;\r\n      nft.transferFrom(address(this), _staker, tokenId);\r\n      token.safeTransferFrom(msg.sender, address(this), 1);\r\n    }\r\n  }\r\n\r\n  // should never be used inside of transaction because of gas fee\r\n  function batchedStakesOfOwner(\r\n      address _owner,\r\n      uint256 _offset,\r\n      uint256 _maxSize\r\n  ) public view returns (uint256[] memory) {\r\n      if (_offset >= ownedStakesBalance[_owner]) {\r\n          return new uint256[](0);\r\n      }\r\n\r\n      uint256 outputSize = _maxSize;\r\n      if (_offset + _maxSize >= ownedStakesBalance[_owner]) {\r\n          outputSize = ownedStakesBalance[_owner] - _offset;\r\n      }\r\n      uint256[] memory outputs = new uint256[](outputSize);\r\n\r\n      for (uint256 i = 0; i < outputSize; i++) {\r\n          uint256 tokenId = ownedStakes[_owner][_offset + i];\r\n          outputs[i] = tokenId;\r\n      }\r\n      return outputs;\r\n  }\r\n\r\n  function onERC721Received(\r\n        address,\r\n        address from,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n      require(from == address(0x0), \"Cannot send nfts to Pit\");\r\n      return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n  \r\n}"
    },
    "contracts/GODtoken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\nimport \"./Operator.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract GODtoken is ERC20Burnable, Operator {\r\n    using SafeMath for uint256;\r\n\r\n    // TOTAL MAX SUPPLY = 50,000 bSHAREs\r\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 1000 ether;\r\n\r\n\r\n    bool public rewardPoolDistributed = false;\r\n\r\n    constructor(\r\n\r\n    ) ERC20(\"GODS\", \"GODs\") {\r\n        _mint(msg.sender, 10 ether); // mint 10 GodTOkens for initial pools deployment\r\n    }\r\n    /**\r\n     * @notice distribute to reward pool (only once)\r\n     */\r\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\r\n        require(!rewardPoolDistributed, \"only can distribute once\");\r\n        require(_farmingIncentiveFund != address(0), \"!_farmingIncentiveFund\");\r\n        rewardPoolDistributed = true;\r\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\r\n    }\r\n\r\n    function burn(uint256 amount) public override {\r\n        super.burn(amount);\r\n    }\r\n\r\n    function governanceRecoverUnsupported(\r\n        IERC20 _token,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyOperator {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Stater.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\nimport \"./owner/Operator.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract Stater is ERC20Burnable, Operator {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    constructor(\r\n\r\n    ) ERC20(\"STATER\", \"STATER\") {\r\n        _mint(msg.sender, 45 ether); // mint 45 STATER for team\r\n    }\r\n\r\n    function burn(uint256 amount) public override {\r\n        super.burn(amount);\r\n    }\r\n\r\n    function governanceRecoverUnsupported(\r\n        IERC20 _token,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyOperator {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * Copyright 2020 Compound Labs, Inc.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its contributors\r\n * may be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\r\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint256;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint256 indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\r\n\r\n    uint256 public constant GRACE_PERIOD = 14 days;\r\n    uint256 public constant MINIMUM_DELAY = 1 days;\r\n    uint256 public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint256 public delay;\r\n\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n    constructor(address admin_, uint256 delay_) {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setDelay(uint256 delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint256) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Epoch.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\r\n\r\nimport '../owner/Operator.sol';\r\n\r\ncontract Epoch is Operator {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private period;\r\n    uint256 private startTime;\r\n    uint256 private lastEpochTime;\r\n    uint256 private epoch;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        uint256 _period,\r\n        uint256 _startTime,\r\n        uint256 _startEpoch\r\n    ) {\r\n        period = _period;\r\n        startTime = _startTime;\r\n        epoch = _startEpoch;\r\n        lastEpochTime = startTime.sub(period);\r\n    }\r\n\r\n    /* ========== Modifier ========== */\r\n\r\n    modifier checkStartTime {\r\n        require(block.timestamp >= startTime, 'Epoch: not started yet');\r\n\r\n        _;\r\n    }\r\n\r\n    modifier checkEpoch {\r\n        uint256 _nextEpochPoint = nextEpochPoint();\r\n        if (block.timestamp < _nextEpochPoint) {\r\n            require(msg.sender == operator(), 'Epoch: only operator allowed for pre-epoch');\r\n            _;\r\n        } else {\r\n            _;\r\n\r\n            for (;;) {\r\n                lastEpochTime = _nextEpochPoint;\r\n                ++epoch;\r\n                _nextEpochPoint = nextEpochPoint();\r\n                if (block.timestamp < _nextEpochPoint) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    function getCurrentEpoch() public view returns (uint256) {\r\n        return epoch;\r\n    }\r\n\r\n    function getPeriod() public view returns (uint256) {\r\n        return period;\r\n    }\r\n\r\n    function getStartTime() public view returns (uint256) {\r\n        return startTime;\r\n    }\r\n\r\n    function getLastEpochTime() public view returns (uint256) {\r\n        return lastEpochTime;\r\n    }\r\n\r\n    function nextEpochPoint() public view returns (uint256) {\r\n        return lastEpochTime.add(period);\r\n    }\r\n\r\n    /* ========== GOVERNANCE ========== */\r\n\r\n    function setPeriod(uint256 _period) external onlyOperator {\r\n        require(_period >= 1 hours && _period <= 48 hours, '_period: out of range');\r\n        period = _period;\r\n    }\r\n\r\n    function setEpoch(uint256 _epoch) external onlyOperator {\r\n        epoch = _epoch;\r\n    }\r\n}\r\n"
    },
    "contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./lib/Babylonian.sol\";\r\nimport \"./lib/FixedPoint.sol\";\r\nimport \"./lib/UniswapV2OracleLibrary.sol\";\r\nimport \"./utils/Epoch.sol\";\r\nimport \"./interfaces/IUniswapV2Pair.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\n// fixed window oracle that recomputes the average price for the entire period once every period\r\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\r\ncontract Oracle is Epoch {\r\n    using FixedPoint for *;\r\n    using SafeMath for uint256;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n    uint public PERIOD = 21600; // 6 hour TWAP (time-weighted average price)\r\n    uint public CONSULT_LENIENCY = 120; // Used for being able to consult past the period end\r\n    bool public ALLOW_STALE_CONSULTS = false; // If false, consult() will fail if the TWAP is stale\r\n    // uniswap\r\n    address public token0;\r\n    address public token1;\r\n    IUniswapV2Pair public pair;\r\n\r\n    // oracle\r\n    uint32 public blockTimestampLast;\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n    FixedPoint.uq112x112 public price0Average;\r\n    FixedPoint.uq112x112 public price1Average;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        IUniswapV2Pair _pair,\r\n        uint256 _period,\r\n        uint256 _startTime\r\n    ) Epoch(_period, _startTime, 0) {\r\n        pair = _pair;\r\n        token0 = pair.token0();\r\n        token1 = pair.token1();\r\n        price0CumulativeLast = pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\r\n        price1CumulativeLast = pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, \"Oracle: NO_RESERVES\"); // ensure that there's liquidity in the pair\r\n    }\r\n\r\n    function setNewPeriod(uint256 _period) external onlyOperator {\r\n        this.setPeriod(_period);\r\n    }\r\n\r\n    function setConsultLeniency(uint _consult_leniency) external onlyOperator {\r\n        CONSULT_LENIENCY = _consult_leniency;\r\n    }\r\n    function setAllowStaleConsults(bool _allow_stale_consults) external onlyOperator {\r\n        ALLOW_STALE_CONSULTS = _allow_stale_consults;\r\n    }\r\n    function canUpdate() public view returns (bool) {\r\n        uint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\r\n        return (timeElapsed >= PERIOD);\r\n    }\r\n\r\n    /* ========== MUTABLE FUNCTIONS ========== */\r\n\r\n    /** @dev Updates 1-day EMA price from Uniswap.  */\r\n    function update() external checkEpoch {\r\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\r\n      \r\n      uint32 timeElapsed;\r\n       unchecked{\r\n        timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n       }\r\n\r\n        // Ensure that at least one full period has passed since the last update\r\n        require(timeElapsed >= PERIOD, \" PERIOD_NOT_ELAPSED\");\r\n\r\n        if (timeElapsed == 0) {\r\n            // prevent divided by zero\r\n            return;\r\n        }\r\n\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        unchecked {\r\n            price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\r\n            price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\r\n        }\r\n\r\n        price0CumulativeLast = price0Cumulative;\r\n        price1CumulativeLast = price1Cumulative;\r\n        blockTimestampLast = blockTimestamp;\r\n\r\n        emit Updated(price0Cumulative, price1Cumulative);\r\n    }\r\n\r\n    // note this will always return 0 before update has been called successfully for the first time.\r\n    function consult(address _token, uint256 _amountIn) external view returns (uint144 amountOut) {\r\n        uint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\r\n        uint32 timeElapsed;\r\n       \r\n        unchecked {\r\n         timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\r\n        }\r\n\r\n        // Ensure that the price is not stale\r\n        require((timeElapsed < (PERIOD + CONSULT_LENIENCY)) || ALLOW_STALE_CONSULTS, \"STALE_PRICE_NEED_TO_CALL_UPDATE\");\r\n\r\n        if (_token == token0) {\r\n            amountOut = price0Average.mul(_amountIn).decode144();\r\n        } else {\r\n            require(_token == token1, \"Oracle: INVALID_TOKEN\");\r\n            amountOut = price1Average.mul(_amountIn).decode144();\r\n        }\r\n    }\r\n\r\n    function twap(address _token, uint256 _amountIn) external view returns (uint144 _amountOut) {\r\n\r\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n\r\n        // Ensure that the price is not stale\r\n        require((timeElapsed < (PERIOD + CONSULT_LENIENCY)) || ALLOW_STALE_CONSULTS, \" STALE_PRICE_NEED_TO_CALL_UPDATE\");\r\n\r\n\r\n        if (_token == token0) {\r\n            _amountOut = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\r\n        } else if (_token == token1) {\r\n            _amountOut = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\r\n        }\r\n    }\r\n\r\n    event Updated(uint256 price0CumulativeLast, uint256 price1CumulativeLast);\r\n}\r\n"
    },
    "contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Babylonian.sol\";\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\r\n    uint256 private constant Q224 = Q112 << RESOLUTION;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\r\n        uint256 z;\r\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\r\n    }\r\n}\r\n"
    },
    "contracts/lib/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./FixedPoint.sol\";\r\nimport \"../interfaces/IUniswapV2Pair.sol\";\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2**32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(address pair)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 price0Cumulative,\r\n            uint256 price1Cumulative,\r\n            uint32 blockTimestamp\r\n        )\r\n    {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"../interfaces/IUniswapV2Pair.sol\";\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            hex\"ff\",\r\n                            factory,\r\n                            keccak256(abi.encodePacked(token0, token1)),\r\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\r\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountIn) {\r\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory,\r\n        uint256 amountIn,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address factory,\r\n        uint256 amountOut,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint256 i = path.length - 1; i > 0; i--) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/distribution/BShareRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n// Note that this pool has no minter key of bSHARE (rewards).\r\n// Instead, the governance will call bSHARE distributeReward method and send reward to this pool at the beginning.\r\ncontract BShareRewardPool is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // governance\r\n    address public operator;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 token; // Address of LP token contract.\r\n        uint256 depFee; // deposit fee that is applied to created pool.\r\n        uint256 allocPoint; // How many allocation points assigned to this pool. bSHAREs to distribute per block.\r\n        uint256 lastRewardTime; // Last time that bSHAREs distribution occurs.\r\n        uint256 accBSharePerShare; // Accumulated bSHAREs per share, times 1e18. See below.\r\n        bool isStarted; // if lastRewardTime has passed\r\n    }\r\n\r\n    IERC20 public bshare;\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n\r\n    // The time when bSHARE mining starts.\r\n    uint256 public poolStartTime;\r\n\r\n    // The time when bSHARE mining ends.\r\n    uint256 public poolEndTime;\r\n\r\n    address public daoFundAddress;\r\n\r\n    uint256 public bSharePerSecond = 0.003486 ether; // 50000 bshare / (166 days * 24h * 60min * 60s)\r\n    uint256 public runningTime = 166 days; // 166 days\r\n    uint256 public constant TOTAL_REWARDS = 50000 ether;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 amount);\r\n\r\n    constructor(\r\n        address _bshare,\r\n        address _daoFund,\r\n        uint256 _poolStartTime\r\n    ) {\r\n        require(block.timestamp < _poolStartTime, \"pool cant be started in the past\");\r\n        if (_bshare != address(0)) bshare = IERC20(_bshare);\r\n        if(_daoFund != address(0)) daoFundAddress = _daoFund;\r\n\r\n        poolStartTime = _poolStartTime;\r\n        poolEndTime = poolStartTime + runningTime;\r\n        operator = msg.sender;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operator == msg.sender, \"BShareRewardPool: caller is not the operator\");\r\n        _;\r\n    }\r\n\r\n    function checkPoolDuplicate(IERC20 _token) internal view {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            require(poolInfo[pid].token != _token, \"BShareRewardPool: existing pool?\");\r\n        }\r\n    }\r\n\r\n    // Add new lp to the pool. Can only be called by operator.\r\n    function add(\r\n        uint256 _allocPoint,\r\n        uint256 _depFee,\r\n        IERC20 _token,\r\n        bool _withUpdate,\r\n        uint256 _lastRewardTime\r\n    ) public onlyOperator {\r\n        checkPoolDuplicate(_token);\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        if (block.timestamp < poolStartTime) {\r\n            // chef is sleeping\r\n            if (_lastRewardTime == 0) {\r\n                _lastRewardTime = poolStartTime;\r\n            } else {\r\n                if (_lastRewardTime < poolStartTime) {\r\n                    _lastRewardTime = poolStartTime;\r\n                }\r\n            }\r\n        } else {\r\n            // chef is cooking\r\n            if (_lastRewardTime == 0 || _lastRewardTime < block.timestamp) {\r\n                _lastRewardTime = block.timestamp;\r\n            }\r\n        }\r\n        bool _isStarted = (_lastRewardTime <= poolStartTime) || (_lastRewardTime <= block.timestamp);\r\n        poolInfo.push(PoolInfo({\r\n            token: _token,\r\n            depFee: _depFee,\r\n            allocPoint: _allocPoint,\r\n            lastRewardTime: _lastRewardTime,\r\n            accBSharePerShare: 0,\r\n            isStarted: _isStarted\r\n        }));\r\n        if (_isStarted) {\r\n            totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        }\r\n    }\r\n\r\n    // starting allocations for our pools\r\n    // BASED-TOMB LP: 21500 $BSHARE\r\n    // BSHARE-TOMB LP: 21000 $BSHARE\r\n    // TEAM: 4500 $BSHARE\r\n    // CURVE STABLES LP (OR GEIST STABLES LP): 3000 $BSHARE\r\n\r\n    // Update the given pool's bSHARE allocation point. Can only be called by the operator.\r\n    // @allocPoints for TEAM can NOT be altered after added - PID 2\r\n    // @allocPoints for main LP pools can NOT be smaller than 12,000\r\n    function set(uint256 _pid, uint256 _allocPoint, uint256 _depFee) public onlyOperator {\r\n        massUpdatePools();\r\n        require (_pid != 2, \"CAN NOT ADJUST TEAM ALLOCATIONS\");\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n\r\n        if (_pid == 0 || _pid == 1) {\r\n            require(_allocPoint >= 12000 * 10**18, \"out of range\"); // >= allocations for lp pools cant be less than 12,000\r\n            if (pool.isStarted) {\r\n                totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(_allocPoint);\r\n            }\r\n        } else if (_pid > 2) {\r\n            require(_allocPoint < 12000 * 10**18, \"cant be more then native lps\");\r\n            require(_depFee < 200);  // deposit fee cant be more than 2%;\r\n            pool.depFee = _depFee;\r\n\r\n            if (pool.isStarted) {\r\n                totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(_allocPoint);\r\n            }\r\n\r\n        }\r\n        pool.allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Return accumulate rewards over the given _from to _to block.\r\n    function getGeneratedReward(uint256 _fromTime, uint256 _toTime) public view returns (uint256) {\r\n        if (_fromTime >= _toTime) return 0;\r\n        if (_toTime >= poolEndTime) {\r\n            if (_fromTime >= poolEndTime) return 0;\r\n            if (_fromTime <= poolStartTime) return poolEndTime.sub(poolStartTime).mul(bSharePerSecond);\r\n            return poolEndTime.sub(_fromTime).mul(bSharePerSecond);\r\n        } else {\r\n            if (_toTime <= poolStartTime) return 0;\r\n            if (_fromTime <= poolStartTime) return _toTime.sub(poolStartTime).mul(bSharePerSecond);\r\n            return _toTime.sub(_fromTime).mul(bSharePerSecond);\r\n        }\r\n    }\r\n\r\n    // View function to see pending bSHAREs on frontend.\r\n    function pendingShare(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accBSharePerShare = pool.accBSharePerShare;\r\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\r\n        if (block.timestamp > pool.lastRewardTime && tokenSupply != 0) {\r\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\r\n            uint256 _bshareReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n            accBSharePerShare = accBSharePerShare.add(_bshareReward.mul(1e18).div(tokenSupply));\r\n        }\r\n        return user.amount.mul(accBSharePerShare).div(1e18).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.timestamp <= pool.lastRewardTime) {\r\n            return;\r\n        }\r\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\r\n        if (tokenSupply == 0) {\r\n            pool.lastRewardTime = block.timestamp;\r\n            return;\r\n        }\r\n        if (!pool.isStarted) {\r\n            pool.isStarted = true;\r\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\r\n        }\r\n        if (totalAllocPoint > 0) {\r\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\r\n            uint256 _bshareReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n            pool.accBSharePerShare = pool.accBSharePerShare.add(_bshareReward.mul(1e18).div(tokenSupply));\r\n        }\r\n        pool.lastRewardTime = block.timestamp;\r\n    }\r\n\r\n    // Deposit LP tokens.\r\n    function deposit(uint256 _pid, uint256 _amount) public nonReentrant {\r\n        address _sender = msg.sender;\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 _pending = user.amount.mul(pool.accBSharePerShare).div(1e18).sub(user.rewardDebt);\r\n            if (_pending > 0) {\r\n                safeBShareTransfer(_sender, _pending);\r\n                emit RewardPaid(_sender, _pending);\r\n            }\r\n        }\r\n        if (_amount > 0 ) {\r\n            pool.token.safeTransferFrom(_sender, address(this), _amount);\r\n            uint256 depositDebt = _amount.mul(pool.depFee).div(10000);\r\n            user.amount = user.amount.add(_amount.sub(depositDebt));\r\n            pool.token.safeTransfer(daoFundAddress, depositDebt);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accBSharePerShare).div(1e18);\r\n        emit Deposit(_sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens.\r\n    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {\r\n        address _sender = msg.sender;\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 _pending = user.amount.mul(pool.accBSharePerShare).div(1e18).sub(user.rewardDebt);\r\n        if (_pending > 0) {\r\n            safeBShareTransfer(_sender, _pending);\r\n            emit RewardPaid(_sender, _pending);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.token.safeTransfer(_sender, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accBSharePerShare).div(1e18);\r\n        emit Withdraw(_sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 _amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.token.safeTransfer(msg.sender, _amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Safe bshare transfer function, just in case if rounding error causes pool to not have enough bSHAREs.\r\n    function safeBShareTransfer(address _to, uint256 _amount) internal {\r\n        uint256 _bshareBal = bshare.balanceOf(address(this));\r\n        if (_bshareBal > 0) {\r\n            if (_amount > _bshareBal) {\r\n                bshare.safeTransfer(_to, _bshareBal);\r\n            } else {\r\n                bshare.safeTransfer(_to, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setOperator(address _operator) external onlyOperator {\r\n        operator = _operator;\r\n    }\r\n}\r\n"
    },
    "contracts/distribution/BasedGenesisRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n// Note that this pool has no minter key of BASED (rewards).\r\n// Instead, the governance will call BASED distributeReward method and send reward to this pool at the beginning.\r\ncontract BasedGenesisRewardPool is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // governance\r\n    address public operator;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How many tokens the user has provided.\r\n        uint256 rewardDebt; // Deposit debt. See explanation below.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 token; // Address of LP token contract.\r\n        uint256 allocPoint; // How many allocation points assigned to this pool. BASED to distribute.\r\n        uint256 lastRewardTime; // Last time that BASED distribution occurs.\r\n        uint256 accBasedPerShare; // Accumulated BASED per share, times 1e18. See below.\r\n        bool isStarted; // if lastRewardBlock has passed\r\n    }\r\n\r\n    IERC20 public based;\r\n\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n\r\n    // Info of each user that stakes tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n\r\n    // The time when BASED mining starts.\r\n    uint256 public poolStartTime;\r\n\r\n    // The time when BASED mining ends.\r\n    uint256 public poolEndTime;\r\n\r\n    address public daoFundAddress;\r\n\r\n\r\n    uint256 public basedPerSecond = 0.159143 ether; // 27500 BASED / (48h * 60min * 60s)\r\n    uint256 public runningTime = 48 hours;\r\n    uint256 public constant TOTAL_REWARDS = 27500 ether;\r\n\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 amount);\r\n\r\n    constructor(\r\n        address _based,\r\n        address _daoFund,\r\n        uint256 _poolStartTime\r\n    ) {\r\n        require(block.timestamp < _poolStartTime, \"late\");\r\n        if (_based != address(0)) based = IERC20(_based);\r\n        if (_daoFund != address(0)) daoFundAddress = _daoFund;\r\n\r\n        poolStartTime = _poolStartTime;\r\n        poolEndTime = poolStartTime + runningTime;\r\n        operator = msg.sender;\r\n\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operator == msg.sender, \"BasedGenesisPool: caller is not the operator\");\r\n        _;\r\n    }\r\n\r\n    function checkPoolDuplicate(IERC20 _token) internal view {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            require(poolInfo[pid].token != _token, \"BasedGenesisPool: existing pool?\");\r\n        }\r\n    }\r\n\r\n    // Add a new pool. Can only be called by the owner.\r\n    // @ _allocPoint - amount of based this pool will emit\r\n    // @ _token - token that can be deposited into this pool\r\n    function add(\r\n        uint256 _allocPoint,\r\n        IERC20 _token,\r\n        bool _withUpdate,\r\n        uint256 _lastRewardTime\r\n    ) public onlyOperator {\r\n        checkPoolDuplicate(_token);\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        if (block.timestamp < poolStartTime) {\r\n            // chef is sleeping\r\n            if (_lastRewardTime == 0) {\r\n                _lastRewardTime = poolStartTime;\r\n            } else {\r\n                if (_lastRewardTime < poolStartTime) {\r\n                    _lastRewardTime = poolStartTime;\r\n                }\r\n            }\r\n        } else {\r\n            // chef is cooking\r\n            if (_lastRewardTime == 0 || _lastRewardTime < block.timestamp) {\r\n                _lastRewardTime = block.timestamp;\r\n            }\r\n        }\r\n        bool _isStarted =\r\n        (_lastRewardTime <= poolStartTime) ||\r\n        (_lastRewardTime <= block.timestamp);\r\n        poolInfo.push(PoolInfo({\r\n        token : _token,\r\n        allocPoint : _allocPoint,\r\n        lastRewardTime : _lastRewardTime,\r\n        accBasedPerShare : 0,\r\n        isStarted : _isStarted\r\n        }));\r\n        if (_isStarted) {\r\n            totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        }\r\n    }\r\n\r\n    // Update the given pool's BASED allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOperator {\r\n        massUpdatePools();\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (pool.isStarted) {\r\n            totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(\r\n                _allocPoint\r\n            );\r\n        }\r\n        pool.allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Return accumulate rewards over the given _from to _to block.\r\n    function getGeneratedReward(uint256 _fromTime, uint256 _toTime) public view returns (uint256) {\r\n        if (_fromTime >= _toTime) return 0;\r\n        if (_toTime >= poolEndTime) {\r\n            if (_fromTime >= poolEndTime) return 0;\r\n            if (_fromTime <= poolStartTime) return poolEndTime.sub(poolStartTime).mul(basedPerSecond);\r\n            return poolEndTime.sub(_fromTime).mul(basedPerSecond);\r\n        } else {\r\n            if (_toTime <= poolStartTime) return 0;\r\n            if (_fromTime <= poolStartTime) return _toTime.sub(poolStartTime).mul(basedPerSecond);\r\n            return _toTime.sub(_fromTime).mul(basedPerSecond);\r\n        }\r\n    }\r\n\r\n    // View function to see pending BASED on frontend.\r\n    function pendingBASED(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accBasedPerShare = pool.accBasedPerShare;\r\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\r\n        if (block.timestamp > pool.lastRewardTime && tokenSupply != 0) {\r\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\r\n            uint256 _multiplyHelper =  _generatedReward.mul(pool.allocPoint); // intermidiate var to avoid multiply and division calc errors\r\n            uint256 _basedReward = _multiplyHelper.div(totalAllocPoint);\r\n            accBasedPerShare = accBasedPerShare.add(_basedReward.mul(1e18).div(tokenSupply));\r\n        }\r\n        // ok so all multiplication can go first and then all divisions go last....same 1 line like before\r\n        return user.amount.mul(accBasedPerShare).div(1e18).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) private  {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.timestamp <= pool.lastRewardTime) {\r\n            return;\r\n        }\r\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\r\n        if (tokenSupply == 0) {\r\n            pool.lastRewardTime = block.timestamp;\r\n            return;\r\n        }\r\n        if (!pool.isStarted) {\r\n            pool.isStarted = true;\r\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\r\n        }\r\n        if (totalAllocPoint > 0) {\r\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\r\n            uint256 multiplyHelper = _generatedReward.mul(pool.allocPoint);\r\n            uint256 _basedReward = multiplyHelper.div(totalAllocPoint);\r\n            pool.accBasedPerShare = pool.accBasedPerShare.add(_basedReward.mul(1e18).div(tokenSupply));\r\n        }\r\n        pool.lastRewardTime = block.timestamp;\r\n    }\r\n\r\n    // Deposit tokens.\r\n\r\n    function deposit(uint256 _pid, uint256 _amount) public nonReentrant {\r\n        address _sender = msg.sender;\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            // transfer rewards to user if any pending rewards\r\n            uint256 _pending = user.amount.mul(pool.accBasedPerShare).div(1e18).sub(user.rewardDebt);\r\n            if (_pending > 0) {\r\n                // send pending reward to user, if rewards accumulating in _pending\r\n                safeBasedTransfer(_sender, _pending);\r\n                emit RewardPaid(_sender, _pending);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.token.safeTransferFrom(_sender, address(this), _amount);\r\n            uint256 depositDebt = _amount.mul(50).div(10000);\r\n            user.amount = user.amount.add(_amount.sub(depositDebt));\r\n            pool.token.safeTransfer(daoFundAddress, depositDebt);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accBasedPerShare).div(1e18);\r\n        emit Deposit(_sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw tokens.\r\n    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {\r\n        address _sender = msg.sender;\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 _pending = user.amount.mul(pool.accBasedPerShare).div(1e18).sub(user.rewardDebt);\r\n        if (_pending > 0) {\r\n            safeBasedTransfer(_sender, _pending);\r\n            emit RewardPaid(_sender, _pending);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.token.safeTransfer(_sender, _amount);\r\n\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accBasedPerShare).div(1e18);\r\n        emit Withdraw(_sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 _amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.token.safeTransfer(msg.sender, _amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Safe BASED transfer function, in case if rounding error causes pool to not have enough BASEDs.\r\n    function safeBasedTransfer(address _to, uint256 _amount) internal {\r\n        uint256 _basedBalance = based.balanceOf(address(this));\r\n        if (_basedBalance > 0) {\r\n            if (_amount > _basedBalance) {\r\n                based.safeTransfer(_to, _basedBalance);\r\n            } else {\r\n                based.safeTransfer(_to, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setOperator(address _operator) external onlyOperator {\r\n        operator = _operator;\r\n    }\r\n}\r\n"
    },
    "contracts/SimpleERCFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\r\n\r\nimport './owner/Operator.sol';\r\nimport './interfaces/ISimpleERCFund.sol';\r\n\r\ncontract SimpleERCFund is ISimpleERCFund, Operator {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function deposit(\r\n        address token,\r\n        uint256 amount,\r\n        string memory reason\r\n    ) public override {\r\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n        emit Deposit(msg.sender, block.timestamp, reason);\r\n    }\r\n\r\n    function withdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address to,\r\n        string memory reason\r\n    ) public override onlyOperator {\r\n        IERC20(token).safeTransfer(to, amount);\r\n        emit Withdrawal(msg.sender, to, block.timestamp, reason);\r\n    }\r\n\r\n    event Deposit(address indexed from, uint256 indexed at, string reason);\r\n    event Withdrawal(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed at,\r\n        string reason\r\n    );\r\n}\r\n"
    },
    "contracts/interfaces/ISimpleERCFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ISimpleERCFund {\r\n    function deposit(\r\n        address token,\r\n        uint256 amount,\r\n        string memory reason\r\n    ) external;\r\n\r\n    function withdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address to,\r\n        string memory reason\r\n    ) external;\r\n}\r\n"
    },
    "contracts/ProfitDistribution.sol": {
      "content": "pragma solidity ^0.8.9;\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./owner/Operator.sol\";\r\n\r\ncontract ProfitDistribution is Operator {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    string public name = \"ProfitDistribution\"; // call it ProfitDistribution\r\n    \r\n    IERC20 public depositToken;\r\n    address public burnAddress;\r\n    uint256 public totalStaked;\r\n    uint256 public depositFee;\r\n    uint256 public totalBurned;\r\n    uint256 public maxWithdrawFee;\r\n    uint256 public feePeriod;\r\n\r\n    //uint256[] public lockMultiplers; for later usage\r\n    uint256 public totalAllocation;\r\n    \r\n    address[] public stakers;\r\n\r\n    struct RewardInfo {\r\n        IERC20 token;\r\n        uint256 rewardsPerEpoch;\r\n        uint256 totalRewards;\r\n        bool isActive;\r\n        uint256 distributedAmount;\r\n        uint256 LastDistributedAmountPerAlloc;\r\n        uint256[] rewardPerAllocHistory;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 balance;\r\n        uint256 allocation;\r\n        bool hasStaked;\r\n        bool isStaking;\r\n        uint256 lastStakedTime;\r\n\r\n        mapping(uint256=> uint256) lastSnapShotIndex; // Maps rewardPoolId to lastSnapshotindex\r\n        mapping(uint256 => uint256) pendingRewards; // Maps rewardPoolId to amount\r\n    }\r\n\r\n\r\n    RewardInfo[] public rewardInfo;\r\n\r\n    \r\n\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    // in constructor pass in the address for reward token 1 and reward token 2\r\n    // that will be used to pay interest\r\n    constructor(IERC20 _depositToken) {\r\n        depositToken = _depositToken;\r\n        burnAddress = 0x000000000000000000000000000000000000dEaD;\r\n        //deposit fee default at 1%\r\n        depositFee = 1000;\r\n\r\n        //max withdraw fee default 7%\r\n\r\n        maxWithdrawFee = 7000;\r\n        \r\n        feePeriod = 7 days;\r\n\r\n        //totalBurned to 0 \r\n\r\n        totalBurned = 0;\r\n    }\r\n\r\n    //Events \r\n\r\n    event UpdateDepositFee(uint256 _depositFee);\r\n    event UpdateMaxWithdrawFee(uint256 _Fee);\r\n\r\n    event AddReward(IERC20 _token);\r\n    event UpdateBurnAddress(address _burnAddress);                    \r\n    event UpdateRewardsPerEpoch(uint256 _rewardId, uint256 _amount);\r\n\r\n    event RewardIncrease(uint256 _rewardId, uint256 _amount);\r\n    event RewardDecrease(uint256 _rewardId, uint256 _amount);\r\n\r\n    event TotalStakedIncrease(uint256 _amount);\r\n    event TotalStakedDecrease(uint256 _amount);\r\n\r\n    event UserStakedIncrease(address _user, uint256 _amount);\r\n    event UserStakedDecrease(address _user, uint256 _amount);\r\n\r\n    event PendingRewardIncrease(address _user, uint256 _rewardId, uint256 _amount);\r\n    event PendingRewardClaimed(address _user);\r\n\r\n    event fees(address _user, uint256 fees);\r\n  \r\n\r\n    //update pending rewards modifier\r\n    modifier updatePendingRewards(address _sender){\r\n        \r\n        UserInfo storage user = userInfo[_sender];\r\n\r\n        for(uint256 i = 0; i < rewardInfo.length; ++i){\r\n            RewardInfo storage reward = rewardInfo[i];\r\n            \r\n            //calculate pending rewards\r\n            user.pendingRewards[i] = earned(_sender, i);\r\n            user.lastSnapShotIndex[i] = reward.rewardPerAllocHistory.length -1;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /*this function calculates the earnings of user over the last recorded \r\n    epoch  to the most recent epoch using average rewardPerAllocation over time*/\r\n\r\n    function earned(address _sender, uint256 _rewardId) public view returns (uint256) {\r\n\r\n        UserInfo storage user = userInfo[_sender];\r\n        RewardInfo storage reward = rewardInfo[_rewardId];\r\n\r\n        uint256 latestRPA = reward.LastDistributedAmountPerAlloc;\r\n        uint256 storedRPA = reward.rewardPerAllocHistory[user.lastSnapShotIndex[_rewardId]];\r\n\r\n        return user.allocation*(latestRPA - storedRPA)/(1e18)+ user.pendingRewards[_rewardId];\r\n    }\r\n\r\n    //update deposit fee\r\n\r\n    function updateDepositFee(uint256 _depositFee) external onlyOperator {\r\n        require(_depositFee < 3000, \"deposit fee too high\");\r\n        depositFee = _depositFee;\r\n        emit UpdateDepositFee(_depositFee);\r\n    }\r\n\r\n    function updateMaxWithdrawFee(uint256 _Fee) external onlyOperator {\r\n        require(_Fee < 10000, \"deposit fee too high\");\r\n        maxWithdrawFee = _Fee;\r\n        emit UpdateMaxWithdrawFee(_Fee);\r\n    }\r\n\r\n    function updateFeeTime(uint256 _time) external onlyOperator {\r\n        require(_time < 30 days, \"deposit fee too high\");\r\n        feePeriod = _time* 1 hours;\r\n    }\r\n\r\n    //add more reward tokens\r\n    function addReward(IERC20 _token) external onlyOperator {\r\n        rewardInfo.push(RewardInfo({\r\n            token: _token,\r\n            rewardsPerEpoch: 0,\r\n            totalRewards: 0,\r\n            isActive: false,\r\n            distributedAmount:0,\r\n            LastDistributedAmountPerAlloc:0,\r\n            rewardPerAllocHistory: new uint256[](1)\r\n        }));\r\n\r\n        emit AddReward(_token);\r\n    }\r\n\r\n    // Update burn address\r\n    function updateBurnAddress(address _burnAddress) external onlyOperator {\r\n        burnAddress = _burnAddress;\r\n        emit UpdateBurnAddress(_burnAddress);\r\n    }\r\n\r\n    // update the rewards per Epoch of each reward token\r\n    function updateRewardsPerEpoch(uint256 _rewardId, uint256 _amount) external onlyOperator {\r\n        RewardInfo storage reward = rewardInfo[_rewardId];\r\n        \r\n        // checking amount\r\n        require(_amount < reward.totalRewards,\"amount must be lower than totalRewards\");\r\n\r\n        // update rewards per epoch\r\n        reward.rewardsPerEpoch = _amount;\r\n\r\n        if (_amount == 0) {\r\n            reward.isActive = false;\r\n        } else {\r\n            reward.isActive = true;\r\n        }\r\n\r\n        emit UpdateRewardsPerEpoch(_rewardId, _amount);\r\n    }\r\n\r\n    // supply rewards to contract\r\n    function supplyRewards(uint256 _rewardId, uint256 _amount) external onlyOperator {\r\n        RewardInfo storage reward = rewardInfo[_rewardId];\r\n\r\n        require(_amount > 0, \"amount must be > 0\");\r\n\r\n        // Update the rewards balance in map\r\n        reward.totalRewards += _amount;\r\n        emit RewardIncrease(_rewardId, _amount);\r\n\r\n        // update status for tracking\r\n        if (reward.totalRewards > 0 && reward.totalRewards > reward.rewardsPerEpoch) {\r\n            reward.isActive = true;\r\n        }\r\n\r\n        // Transfer reward tokens to contract\r\n        reward.token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        \r\n    }\r\n    \r\n\r\n    //withdraw rewards out of contract\r\n    function withdrawRewards(uint256 _rewardId, uint256 _amount) external onlyOperator {\r\n        RewardInfo storage reward = rewardInfo[_rewardId];\r\n\r\n        require(_amount <= reward.totalRewards, \"amount should be less than total rewards\");\r\n\r\n        // Update the rewards balance in map\r\n        reward.totalRewards -= _amount;\r\n        emit RewardDecrease(_rewardId, _amount);\r\n\r\n        // update status for tracking\r\n        if (reward.totalRewards == 0 || reward.totalRewards < reward.rewardsPerEpoch) {\r\n            reward.isActive = false;\r\n        }\r\n\r\n        // Transfer reward tokens out of contract \r\n        reward.token.safeTransfer(msg.sender, _amount);\r\n    }\r\n\r\n    function stakeTokens(uint256 _amount) external updatePendingRewards(msg.sender){\r\n        address _sender = msg.sender;\r\n        UserInfo storage user = userInfo[_sender];\r\n\r\n        require(_amount > 0, \"can't stake 0\");\r\n        user.lastStakedTime = block.timestamp;\r\n        // 1% fee calculation \r\n        uint256 feeAmount = _amount * depositFee / 100000;\r\n        uint256 depositAmount = _amount - feeAmount;\r\n\r\n        //update totalBurned\r\n        totalBurned += feeAmount;\r\n\r\n        // Update the staking balance in map\r\n        user.balance += depositAmount;\r\n        emit UserStakedIncrease(_sender, depositAmount);\r\n\r\n        //update allocation \r\n        user.allocation += depositAmount;\r\n        totalAllocation += depositAmount;\r\n\r\n        //update TotalStaked\r\n        totalStaked += depositAmount;\r\n        emit TotalStakedIncrease(depositAmount);\r\n\r\n        // Add user to stakers array if they haven't staked already\r\n        if(!user.hasStaked) {\r\n            stakers.push(_sender);\r\n        }\r\n\r\n        // Update staking status to track\r\n        user.isStaking = true;\r\n        user.hasStaked = true;\r\n\r\n        // Transfer based tokens to contract for staking\r\n        depositToken.safeTransferFrom(_sender, address(this), _amount);\r\n\r\n        // burn based\r\n        depositToken.safeTransfer(burnAddress, feeAmount);\r\n    }\r\n        \r\n    // allow user to unstake total balance and withdraw USDC from the contract\r\n    function unstakeTokens(uint256 _amount) external updatePendingRewards(msg.sender) {\r\n        address _sender = msg.sender;\r\n        UserInfo storage user = userInfo[_sender];\r\n\r\n        require(_amount > 0, \"can't unstake 0\");\r\n\r\n        //check if amount is less than balance\r\n        require(_amount <= user.balance, \"staking balance too low\");\r\n\r\n        //calculate fees\r\n        uint current_fee = 0;\r\n        if (feePeriod > (block.timestamp - user.lastStakedTime)){\r\n            current_fee = (feePeriod - (block.timestamp - user.lastStakedTime))*(1e18)/(feePeriod)*maxWithdrawFee/1e18;\r\n            emit fees(msg.sender, current_fee);\r\n        }\r\n      \r\n\r\n        uint256 feeAmount = _amount * current_fee / 100000;\r\n        uint256 WithdrawAmount = _amount - feeAmount;\r\n\r\n        //update user balance\r\n        user.balance -= _amount;\r\n        emit UserStakedDecrease(_sender, _amount);\r\n\r\n        //update allocation \r\n        user.allocation -= _amount;\r\n        totalAllocation -= _amount;\r\n\r\n        //update totalStaked\r\n        totalStaked -= _amount;\r\n        emit TotalStakedDecrease(_amount);\r\n    \r\n        // update the staking status\r\n        if (user.balance == 0) {\r\n            user.isStaking = false;\r\n        }\r\n        \r\n        // transfer staked tokens out of this contract to the msg.sender\r\n        depositToken.safeTransfer(_sender, WithdrawAmount);\r\n        if (feeAmount > 0){\r\n\r\n            totalBurned += feeAmount;\r\n            depositToken.safeTransfer(burnAddress, feeAmount);\r\n        }\r\n        \r\n    }\r\n\r\n    function issueInterestToken(uint256 _rewardId) public onlyOperator {\r\n        RewardInfo storage reward = rewardInfo[_rewardId];\r\n        require(reward.isActive, \"No rewards\");\r\n\r\n        //update distributed amount and reward per allocations\r\n        reward.distributedAmount += reward.rewardsPerEpoch;\r\n\r\n        uint256 thisEpochRPA = reward.rewardsPerEpoch*(1e18)/totalAllocation;\r\n\r\n        reward.LastDistributedAmountPerAlloc = reward.LastDistributedAmountPerAlloc + thisEpochRPA;\r\n        reward.rewardPerAllocHistory.push(reward.LastDistributedAmountPerAlloc);\r\n        \r\n        if(reward.totalRewards > 0) {\r\n                //update totalRewards \r\n                reward.totalRewards -= reward.rewardsPerEpoch;\r\n                emit RewardDecrease(_rewardId, reward.rewardsPerEpoch);\r\n        }\r\n            \r\n\r\n        if (reward.totalRewards == 0 || reward.totalRewards < reward.rewardsPerEpoch) {\r\n            reward.isActive = false;\r\n        }\r\n    }\r\n\r\n    //get pending rewards\r\n    function getPendingRewards(uint256 _rewardId, address _user) external view returns(uint256) {\r\n         UserInfo storage user = userInfo[_user];\r\n         return user.pendingRewards[_rewardId];\r\n    }\r\n\r\n        //get pending rewards\r\n    function getLastSnapShotIndex(uint256 _rewardId, address _user) external view returns(uint256) {\r\n         UserInfo storage user = userInfo[_user];\r\n         return user.lastSnapShotIndex[_rewardId];\r\n    }\r\n\r\n    \r\n    //collect rewards\r\n\r\n    function collectRewards() external updatePendingRewards(msg.sender) {\r\n        \r\n        address _sender = msg.sender;\r\n\r\n        \r\n        UserInfo storage user = userInfo[_sender];\r\n\r\n        //update pendingRewards and collectRewards\r\n\r\n        //loop through the reward IDs\r\n        for(uint256 i = 0; i < rewardInfo.length; ++i){\r\n            //if pending rewards is not 0 \r\n            if (user.pendingRewards[i] > 0){\r\n                \r\n                RewardInfo storage reward = rewardInfo[i];\r\n                uint256 rewardsClaim = user.pendingRewards[i];\r\n                //reset pending rewards \r\n                user.pendingRewards[i] = 0;\r\n                \r\n                //send rewards\r\n                emit PendingRewardClaimed(_sender);\r\n                reward.token.safeTransfer(_sender, rewardsClaim);\r\n            }\r\n        }\r\n    }\r\n\r\n    //get the pool share of a staker\r\n    function getPoolShare(address _user) public view returns(uint256) {\r\n        return (userInfo[_user].allocation * (1e18)) / totalStaked;\r\n    }\r\n\r\n    function distributeRewards() external onlyOperator {\r\n        uint256 length = rewardInfo.length;\r\n        for (uint256 i = 0; i < length; ++ i) {\r\n            if (rewardInfo[i].isActive) {\r\n                issueInterestToken(i);\r\n            }\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/interfaces/IWrappedFtm.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IWrappedFtm is IERC20 {\r\n    function deposit() external payable returns (uint256);\r\n\r\n    function withdraw(uint256 amount) external returns (uint256);\r\n\r\n}\r\n\r\n"
    },
    "contracts/BShare.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\nimport \"./owner/Operator.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract BShare is ERC20Burnable, Operator {\r\n    using SafeMath for uint256;\r\n\r\n    // TOTAL MAX SUPPLY = 50,000 bSHAREs\r\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 50000 ether;\r\n\r\n\r\n    bool public rewardPoolDistributed = false;\r\n\r\n    constructor(\r\n\r\n    ) ERC20(\"BSHARE\", \"BSHARE\") {\r\n        _mint(msg.sender, 10 ether); // mint 10 BShare for initial pools deployment\r\n    }\r\n    /**\r\n     * @notice distribute to reward pool (only once)\r\n     */\r\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\r\n        require(!rewardPoolDistributed, \"only can distribute once\");\r\n        require(_farmingIncentiveFund != address(0), \"!_farmingIncentiveFund\");\r\n        rewardPoolDistributed = true;\r\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\r\n    }\r\n\r\n    function burn(uint256 amount) public override {\r\n        super.burn(amount);\r\n    }\r\n\r\n    function governanceRecoverUnsupported(\r\n        IERC20 _token,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyOperator {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/Based.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./lib/SafeMath8.sol\";\r\nimport \"./owner/Operator.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract Based is ERC20Burnable, Operator {\r\n    using SafeMath8 for uint8;\r\n    using SafeMath for uint256;\r\n\r\n    // Initial distribution for the first 48h genesis pools\r\n    // total of based we pay to users during genesis\r\n    uint256 public constant INITIAL_GENESIS_POOL_DISTRIBUTION = 27500 ether;\r\n\r\n    // DAO FUND INITIAL ALLOCATION IS 1000 BASED\r\n    uint256 public constant INITIAL_DAOFUND_DISTRIBUTION = 1000 ether;\r\n\r\n\r\n    // Have the rewards been distributed to the pools\r\n    bool public rewardPoolDistributed = false;\r\n\r\n\r\n    // Address of the Oracle\r\n    address public basedOracle;\r\n\r\n    /**\r\n     * @notice Constructs the BASED ERC-20 contract.\r\n     */\r\n    constructor() ERC20(\"BASED\", \"BASED\") {\r\n        // Mints 5000 BASED to contract creator for initial pool setup\r\n\r\n        _mint(msg.sender, 5000 ether);\r\n\r\n    }\r\n\r\n    function _getBasedPrice() internal view returns (uint256 _basedPrice) {\r\n        try IOracle(basedOracle).consult(address(this), 1e18) returns (uint144 _price) {\r\n            return uint256(_price);\r\n        } catch {\r\n            revert(\"Based: failed to fetch BASED price from Oracle\");\r\n        }\r\n    }\r\n\r\n    function setBasedOracle(address _basedOracle) public onlyOperator {\r\n        require(_basedOracle != address(0), \"oracle address cannot be 0 address\");\r\n        basedOracle = _basedOracle;\r\n    }\r\n\r\n    /**\r\n     * @notice Operator mints BASED to a recipient\r\n     * @param recipient_ The address of recipient\r\n     * @param amount_ The amount of BASED to mint to\r\n     * @return whether the process has been done\r\n     */\r\n    function mint(address recipient_, uint256 amount_) public onlyOperator returns (bool) {\r\n        uint256 balanceBefore = balanceOf(recipient_);\r\n        _mint(recipient_, amount_);\r\n        uint256 balanceAfter = balanceOf(recipient_);\r\n\r\n        return balanceAfter > balanceBefore;\r\n    }\r\n\r\n    function burn(uint256 amount) public override {\r\n        super.burn(amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public override onlyOperator {\r\n        super.burnFrom(account, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), allowance(sender, _msgSender()).sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice distribute to reward pool (only once)\r\n     */\r\n    function distributeReward(\r\n        address _genesisPool,\r\n        address _daoFund\r\n\r\n    ) external onlyOperator {\r\n        require(!rewardPoolDistributed, \"only can distribute once\");\r\n        require(_genesisPool != address(0), \"!_genesisPool\");\r\n        require(_daoFund != address(0), \"!_treasury\");\r\n\r\n        rewardPoolDistributed = true;\r\n        _mint(_genesisPool, INITIAL_GENESIS_POOL_DISTRIBUTION);\r\n        _mint(_daoFund, INITIAL_DAOFUND_DISTRIBUTION);\r\n\r\n    }\r\n\r\n    function governanceRecoverUnsupported(\r\n        IERC20 _token,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyOperator {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n}"
    },
    "contracts/lib/SafeMath8.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath8 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\r\n        require(b <= a, errorMessage);\r\n        uint8 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint8 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\r\n        require(b > 0, errorMessage);\r\n        uint8 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/BBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\nimport \"./owner/Operator.sol\";\r\n\r\n/*\r\n__________                             .___   ___________.__\r\n\\______   \\_____     ______  ____    __| _/   \\_   _____/|__|  ____  _____     ____    ____   ____\r\n |    |  _/\\__  \\   /  ___/_/ __ \\  / __ |     |    __)  |  | /    \\ \\__  \\   /    \\ _/ ___\\_/ __ \\\r\n |    |   \\ / __ \\_ \\___ \\ \\  ___/ / /_/ |     |     \\   |  ||   |  \\ / __ \\_|   |  \\\\  \\___\\  ___/\r\n |______  /(____  //____  > \\___  >\\____ |     \\___  /   |__||___|  /(____  /|___|  / \\___  >\\___  >\r\n        \\/      \\/      \\/      \\/      \\/         \\/             \\/      \\/      \\/      \\/     \\/\r\n*/\r\ncontract BBond is ERC20Burnable, Operator {\r\n    /**\r\n     * @notice Constructs the BASED Bond ERC-20 contract.\r\n     */\r\n    constructor() ERC20(\"BBOND\", \"BBOND\") {}\r\n\r\n    /**\r\n     * @notice Operator mints basis bonds to a recipient\r\n     * @param recipient_ The address of recipient\r\n     * @param amount_ The amount of basis bonds to mint to\r\n     * @return whether the process has been done\r\n     */\r\n    function mint(address recipient_, uint256 amount_) public onlyOperator returns (bool) {\r\n        uint256 balanceBefore = balanceOf(recipient_);\r\n        _mint(recipient_, amount_);\r\n        uint256 balanceAfter = balanceOf(recipient_);\r\n\r\n        return balanceAfter > balanceBefore;\r\n    }\r\n\r\n    function burn(uint256 amount) public override {\r\n        super.burn(amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public override onlyOperator {\r\n        super.burnFrom(account, amount);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}